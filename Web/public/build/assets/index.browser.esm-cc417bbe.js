import{s as qs,g as Yt,d as fi,c as Ze,b as U,a as hi,B as Yn}from"./bn-a0a0c8e1.js";import{s as pi}from"./sha512-d6693c92.js";import{r as yi,w as gi,a as bi,n as Jn,b as mi,i as Xn,c as Zn,e as Qn,t as wi,m as ki,o as Si,s as vi,p as Ii,q as _i,v as Ai,x as Ei}from"./_md-5eb5ac83.js";import{v as Ri,a as xi,e as ut,b as Rr,n as es,c as Bi,w as Pi,d as ts,m as st,F as Ti,f as Li,i as Ci,p as je,s as cn,g as rs}from"./secp256k1-a06cb75b.js";import{r as Oi}from"./encoding-e26e765b.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qe=BigInt(0),Oe=BigInt(1),sr=BigInt(2),zi=BigInt(8),Ni={zip215:!0};function Ui(s){const e=Ri(s);return xi(s,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Ki(s){const e=Ui(s),{Fp:t,n:r,prehash:n,hash:o,randomBytes:i,nByteLength:a,h:c}=e,l=sr<<BigInt(a*8)-Oe,u=t.create,p=e.uvRatio||((F,g)=>{try{return{isValid:!0,value:t.sqrt(F*t.inv(g))}}catch{return{isValid:!1,value:qe}}}),k=e.adjustScalarBytes||(F=>F),d=e.domain||((F,g,m)=>{if(g.length||m)throw new Error("Contexts/pre-hash are not supported");return F}),b=F=>typeof F=="bigint"&&qe<F,w=(F,g)=>b(F)&&b(g)&&F<g,h=F=>F===qe||w(F,l);function I(F,g){if(w(F,g))return F;throw new Error(`Expected valid scalar < ${g}, got ${typeof F} ${F}`)}function R(F){return F===qe?F:I(F,r)}const v=new Map;function A(F){if(!(F instanceof B))throw new Error("ExtendedPoint expected")}class B{constructor(g,m,S,L){if(this.ex=g,this.ey=m,this.ez=S,this.et=L,!h(g))throw new Error("x required");if(!h(m))throw new Error("y required");if(!h(S))throw new Error("z required");if(!h(L))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(g){if(g instanceof B)throw new Error("extended point not allowed");const{x:m,y:S}=g||{};if(!h(m)||!h(S))throw new Error("invalid affine point");return new B(m,S,Oe,u(m*S))}static normalizeZ(g){const m=t.invertBatch(g.map(S=>S.ez));return g.map((S,L)=>S.toAffine(m[L])).map(B.fromAffine)}_setWindowSize(g){this._WINDOW_SIZE=g,v.delete(this)}assertValidity(){const{a:g,d:m}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:S,ey:L,ez:z,et:C}=this,j=u(S*S),H=u(L*L),J=u(z*z),ce=u(J*J),de=u(j*g),ye=u(J*u(de+H)),Be=u(ce+u(m*u(j*H)));if(ye!==Be)throw new Error("bad point: equation left != right (1)");const ct=u(S*L),nt=u(z*C);if(ct!==nt)throw new Error("bad point: equation left != right (2)")}equals(g){A(g);const{ex:m,ey:S,ez:L}=this,{ex:z,ey:C,ez:j}=g,H=u(m*j),J=u(z*L),ce=u(S*j),de=u(C*L);return H===J&&ce===de}is0(){return this.equals(B.ZERO)}negate(){return new B(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:g}=e,{ex:m,ey:S,ez:L}=this,z=u(m*m),C=u(S*S),j=u(sr*u(L*L)),H=u(g*z),J=m+S,ce=u(u(J*J)-z-C),de=H+C,ye=de-j,Be=H-C,ct=u(ce*ye),nt=u(de*Be),rr=u(ce*Be),nr=u(ye*de);return new B(ct,nt,nr,rr)}add(g){A(g);const{a:m,d:S}=e,{ex:L,ey:z,ez:C,et:j}=this,{ex:H,ey:J,ez:ce,et:de}=g;if(m===BigInt(-1)){const Mn=u((z-L)*(J+H)),Fn=u((z+L)*(J-H)),Er=u(Fn-Mn);if(Er===qe)return this.double();const Vn=u(C*sr*de),$n=u(j*sr*ce),jn=$n+Vn,Hn=Fn+Mn,Gn=$n-Vn,ci=u(jn*Er),ui=u(Hn*Gn),li=u(jn*Gn),di=u(Er*Hn);return new B(ci,ui,di,li)}const ye=u(L*H),Be=u(z*J),ct=u(j*S*de),nt=u(C*ce),rr=u((L+z)*(H+J)-ye-Be),nr=nt-ct,Dn=nt+ct,qn=u(Be-m*ye),si=u(rr*nr),oi=u(Dn*qn),ii=u(rr*qn),ai=u(nr*Dn);return new B(si,oi,ai,ii)}subtract(g){return this.add(g.negate())}wNAF(g){return K.wNAFCached(this,v,g,B.normalizeZ)}multiply(g){const{p:m,f:S}=this.wNAF(I(g,r));return B.normalizeZ([m,S])[0]}multiplyUnsafe(g){let m=R(g);return m===qe?W:this.equals(W)||m===Oe?this:this.equals(_)?this.wNAF(m).p:K.unsafeLadder(this,m)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return K.unsafeLadder(this,r).is0()}toAffine(g){const{ex:m,ey:S,ez:L}=this,z=this.is0();g==null&&(g=z?zi:t.inv(L));const C=u(m*g),j=u(S*g),H=u(L*g);if(z)return{x:qe,y:Oe};if(H!==Oe)throw new Error("invZ was invalid");return{x:C,y:j}}clearCofactor(){const{h:g}=e;return g===Oe?this:this.multiplyUnsafe(g)}static fromHex(g,m=!1){const{d:S,a:L}=e,z=t.BYTES;g=ut("pointHex",g,z);const C=g.slice(),j=g[z-1];C[z-1]=j&-129;const H=Rr(C);H===qe||(m?I(H,l):I(H,t.ORDER));const J=u(H*H),ce=u(J-Oe),de=u(S*J-L);let{isValid:ye,value:Be}=p(ce,de);if(!ye)throw new Error("Point.fromHex: invalid y coordinate");const ct=(Be&Oe)===Oe,nt=(j&128)!==0;if(!m&&Be===qe&&nt)throw new Error("Point.fromHex: x=0 and x_0=1");return nt!==ct&&(Be=u(-Be)),B.fromAffine({x:Be,y:H})}static fromPrivateKey(g){return Ie(g).point}toRawBytes(){const{x:g,y:m}=this.toAffine(),S=es(m,t.BYTES);return S[S.length-1]|=g&Oe?128:0,S}toHex(){return Bi(this.toRawBytes())}}B.BASE=new B(e.Gx,e.Gy,Oe,u(e.Gx*e.Gy)),B.ZERO=new B(qe,Oe,Oe,qe);const{BASE:_,ZERO:W}=B,K=Pi(B,a*8);function $(F){return st(F,r)}function le(F){return $(Rr(F))}function Ie(F){const g=a;F=ut("private key",F,g);const m=ut("hashed private key",o(F),2*g),S=k(m.slice(0,g)),L=m.slice(g,2*g),z=le(S),C=_.multiply(z),j=C.toRawBytes();return{head:S,prefix:L,scalar:z,point:C,pointBytes:j}}function $e(F){return Ie(F).pointBytes}function De(F=new Uint8Array,...g){const m=ts(...g);return le(o(d(m,ut("context",F),!!n)))}function Et(F,g,m={}){F=ut("message",F),n&&(F=n(F));const{prefix:S,scalar:L,pointBytes:z}=Ie(g),C=De(m.context,S,F),j=_.multiply(C).toRawBytes(),H=De(m.context,j,z,F),J=$(C+H*L);R(J);const ce=ts(j,es(J,t.BYTES));return ut("result",ce,a*2)}const Rt=Ni;function yt(F,g,m,S=Rt){const{context:L,zip215:z}=S,C=t.BYTES;F=ut("signature",F,2*C),g=ut("message",g),n&&(g=n(g));const j=Rr(F.slice(C,2*C));let H,J,ce;try{H=B.fromHex(m,z),J=B.fromHex(F.slice(0,C),z),ce=_.multiplyUnsafe(j)}catch{return!1}if(!z&&H.isSmallOrder())return!1;const de=De(L,J.toRawBytes(),H.toRawBytes(),g);return J.add(H.multiplyUnsafe(de)).subtract(ce).clearCofactor().equals(B.ZERO)}return _._setWindowSize(8),{CURVE:e,getPublicKey:$e,sign:Et,verify:yt,ExtendedPoint:B,utils:{getExtendedPublicKey:Ie,randomPrivateKey:()=>i(t.BYTES),precompute(F=8,g=B.BASE){return g._setWindowSize(F),g.multiply(BigInt(3)),g}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const un=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),ns=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Wi=BigInt(1),Zr=BigInt(2),Di=BigInt(5),ss=BigInt(10),qi=BigInt(20),Mi=BigInt(40),os=BigInt(80);function Fi(s){const e=un,r=s*s%e*s%e,n=je(r,Zr,e)*r%e,o=je(n,Wi,e)*s%e,i=je(o,Di,e)*o%e,a=je(i,ss,e)*i%e,c=je(a,qi,e)*a%e,l=je(c,Mi,e)*c%e,u=je(l,os,e)*l%e,p=je(u,os,e)*l%e,k=je(p,ss,e)*i%e;return{pow_p_5_8:je(k,Zr,e)*s%e,b2:r}}function Vi(s){return s[0]&=248,s[31]&=127,s[31]|=64,s}function $i(s,e){const t=un,r=st(e*e*e,t),n=st(r*r*e,t),o=Fi(s*n).pow_p_5_8;let i=st(s*r*o,t);const a=st(e*i*i,t),c=i,l=st(i*ns,t),u=a===s,p=a===st(-s,t),k=a===st(-s*ns,t);return u&&(i=c),(p||k)&&(i=l),Ci(i,t)&&(i=st(-i,t)),{isValid:u||p,value:i}}const at=Ti(un,void 0,!0),ji={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:at,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:pi,randomBytes:yi,adjustScalarBytes:Vi,uvRatio:$i},Nt=Ki(ji),Hi=(at.ORDER+BigInt(3))/BigInt(8);at.pow(Zr,Hi);at.sqrt(at.neg(at.ONE));(at.ORDER-BigInt(5))/BigInt(8);BigInt(486662);Li(at,at.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var or=qs.Buffer;function Gi(s){if(s.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var r=0;r<s.length;r++){var n=s.charAt(r),o=n.charCodeAt(0);if(e[o]!==255)throw new TypeError(n+" is ambiguous");e[o]=r}var i=s.length,a=s.charAt(0),c=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function u(d){if((Array.isArray(d)||d instanceof Uint8Array)&&(d=or.from(d)),!or.isBuffer(d))throw new TypeError("Expected Buffer");if(d.length===0)return"";for(var b=0,w=0,h=0,I=d.length;h!==I&&d[h]===0;)h++,b++;for(var R=(I-h)*l+1>>>0,v=new Uint8Array(R);h!==I;){for(var A=d[h],B=0,_=R-1;(A!==0||B<w)&&_!==-1;_--,B++)A+=256*v[_]>>>0,v[_]=A%i>>>0,A=A/i>>>0;if(A!==0)throw new Error("Non-zero carry");w=B,h++}for(var W=R-w;W!==R&&v[W]===0;)W++;for(var K=a.repeat(b);W<R;++W)K+=s.charAt(v[W]);return K}function p(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return or.alloc(0);for(var b=0,w=0,h=0;d[b]===a;)w++,b++;for(var I=(d.length-b)*c+1>>>0,R=new Uint8Array(I);d[b];){var v=e[d.charCodeAt(b)];if(v===255)return;for(var A=0,B=I-1;(v!==0||A<h)&&B!==-1;B--,A++)v+=i*R[B]>>>0,R[B]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");h=A,b++}for(var _=I-h;_!==I&&R[_]===0;)_++;var W=or.allocUnsafe(w+(I-_));W.fill(0,0,w);for(var K=w;_!==I;)W[K++]=R[_++];return W}function k(d){var b=p(d);if(b)return b;throw new Error("Non-base"+i+" character")}return{encode:u,decodeUnsafe:p,decode:k}}var Yi=Gi,Ji=Yi,Xi="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Zi=Ji(Xi);const Se=Yt(Zi);var ke={},ir=qs.Buffer;function Qi(s){if(s.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var r=0;r<s.length;r++){var n=s.charAt(r),o=n.charCodeAt(0);if(e[o]!==255)throw new TypeError(n+" is ambiguous");e[o]=r}var i=s.length,a=s.charAt(0),c=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function u(d){if((Array.isArray(d)||d instanceof Uint8Array)&&(d=ir.from(d)),!ir.isBuffer(d))throw new TypeError("Expected Buffer");if(d.length===0)return"";for(var b=0,w=0,h=0,I=d.length;h!==I&&d[h]===0;)h++,b++;for(var R=(I-h)*l+1>>>0,v=new Uint8Array(R);h!==I;){for(var A=d[h],B=0,_=R-1;(A!==0||B<w)&&_!==-1;_--,B++)A+=256*v[_]>>>0,v[_]=A%i>>>0,A=A/i>>>0;if(A!==0)throw new Error("Non-zero carry");w=B,h++}for(var W=R-w;W!==R&&v[W]===0;)W++;for(var K=a.repeat(b);W<R;++W)K+=s.charAt(v[W]);return K}function p(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return ir.alloc(0);for(var b=0,w=0,h=0;d[b]===a;)w++,b++;for(var I=(d.length-b)*c+1>>>0,R=new Uint8Array(I);d[b];){var v=e[d.charCodeAt(b)];if(v===255)return;for(var A=0,B=I-1;(v!==0||A<h)&&B!==-1;B--,A++)v+=i*R[B]>>>0,R[B]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");h=A,b++}for(var _=I-h;_!==I&&R[_]===0;)_++;var W=ir.allocUnsafe(w+(I-_));W.fill(0,0,w);for(var K=w;_!==I;)W[K++]=R[_++];return W}function k(d){var b=p(d);if(b)return b;throw new Error("Non-base"+i+" character")}return{encode:u,decodeUnsafe:p,decode:k}}var ea=Qi,ta=ea,ra="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",na=ta(ra),sa=Ze&&Ze.__createBinding||(Object.create?function(s,e,t,r){r===void 0&&(r=t),Object.defineProperty(s,r,{enumerable:!0,get:function(){return e[t]}})}:function(s,e,t,r){r===void 0&&(r=t),s[r]=e[t]}),oa=Ze&&Ze.__setModuleDefault||(Object.create?function(s,e){Object.defineProperty(s,"default",{enumerable:!0,value:e})}:function(s,e){s.default=e}),et=Ze&&Ze.__decorate||function(s,e,t,r){var n=arguments.length,o=n<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(s,e,t,r);else for(var a=s.length-1;a>=0;a--)(i=s[a])&&(o=(n<3?i(o):n>3?i(e,t,o):i(e,t))||o);return n>3&&o&&Object.defineProperty(e,t,o),o},ia=Ze&&Ze.__importStar||function(s){if(s&&s.__esModule)return s;var e={};if(s!=null)for(var t in s)t!=="default"&&Object.hasOwnProperty.call(s,t)&&sa(e,s,t);return oa(e,s),e},Ms=Ze&&Ze.__importDefault||function(s){return s&&s.__esModule?s:{default:s}};Object.defineProperty(ke,"__esModule",{value:!0});var Fs=ke.deserializeUnchecked=Ys=ke.deserialize=Gs=ke.serialize=ke.BinaryReader=ke.BinaryWriter=ke.BorshError=ke.baseDecode=ke.baseEncode=void 0;const lt=Ms(fi),Vs=Ms(na),aa=ia(Oi),ca=typeof TextDecoder!="function"?aa.TextDecoder:TextDecoder,ua=new ca("utf-8",{fatal:!0});function la(s){return typeof s=="string"&&(s=U.Buffer.from(s,"utf8")),Vs.default.encode(U.Buffer.from(s))}ke.baseEncode=la;function da(s){return U.Buffer.from(Vs.default.decode(s))}ke.baseDecode=da;const xr=1024;class xe extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}ke.BorshError=xe;class $s{constructor(){this.buf=U.Buffer.alloc(xr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=U.Buffer.concat([this.buf,U.Buffer.alloc(xr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(U.Buffer.from(new lt.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(U.Buffer.from(new lt.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(U.Buffer.from(new lt.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(U.Buffer.from(new lt.default(e).toArray("le",64)))}writeBuffer(e){this.buf=U.Buffer.concat([U.Buffer.from(this.buf.subarray(0,this.length)),e,U.Buffer.alloc(xr)]),this.length+=e.length}writeString(e){this.maybeResize();const t=U.Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(U.Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const r of e)this.maybeResize(),t(r)}toArray(){return this.buf.subarray(0,this.length)}}ke.BinaryWriter=$s;function tt(s,e,t){const r=t.value;t.value=function(...n){try{return r.apply(this,n)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new xe("Reached the end of buffer when deserializing")}throw o}}}class Ue{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new lt.default(e,"le")}readU128(){const e=this.readBuffer(16);return new lt.default(e,"le")}readU256(){const e=this.readBuffer(32);return new lt.default(e,"le")}readU512(){const e=this.readBuffer(64);return new lt.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new xe(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return ua.decode(t)}catch(r){throw new xe(`Error decoding UTF-8 string: ${r}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),r=Array();for(let n=0;n<t;++n)r.push(e());return r}}et([tt],Ue.prototype,"readU8",null);et([tt],Ue.prototype,"readU16",null);et([tt],Ue.prototype,"readU32",null);et([tt],Ue.prototype,"readU64",null);et([tt],Ue.prototype,"readU128",null);et([tt],Ue.prototype,"readU256",null);et([tt],Ue.prototype,"readU512",null);et([tt],Ue.prototype,"readString",null);et([tt],Ue.prototype,"readFixedArray",null);et([tt],Ue.prototype,"readArray",null);ke.BinaryReader=Ue;function js(s){return s.charAt(0).toUpperCase()+s.slice(1)}function gt(s,e,t,r,n){try{if(typeof r=="string")n[`write${js(r)}`](t);else if(r instanceof Array)if(typeof r[0]=="number"){if(t.length!==r[0])throw new xe(`Expecting byte array of length ${r[0]}, but got ${t.length} bytes`);n.writeFixedArray(t)}else if(r.length===2&&typeof r[1]=="number"){if(t.length!==r[1])throw new xe(`Expecting byte array of length ${r[1]}, but got ${t.length} bytes`);for(let o=0;o<r[1];o++)gt(s,null,t[o],r[0],n)}else n.writeArray(t,o=>{gt(s,e,o,r[0],n)});else if(r.kind!==void 0)switch(r.kind){case"option":{t==null?n.writeU8(0):(n.writeU8(1),gt(s,e,t,r.type,n));break}case"map":{n.writeU32(t.size),t.forEach((o,i)=>{gt(s,e,i,r.key,n),gt(s,e,o,r.value,n)});break}default:throw new xe(`FieldType ${r} unrecognized`)}else Hs(s,t,n)}catch(o){throw o instanceof xe&&o.addToFieldPath(e),o}}function Hs(s,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const r=s.get(e.constructor);if(!r)throw new xe(`Class ${e.constructor.name} is missing in schema`);if(r.kind==="struct")r.fields.map(([n,o])=>{gt(s,n,e[n],o,t)});else if(r.kind==="enum"){const n=e[r.field];for(let o=0;o<r.values.length;++o){const[i,a]=r.values[o];if(i===n){t.writeU8(o),gt(s,i,e[i],a,t);break}}}else throw new xe(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function fa(s,e,t=$s){const r=new t;return Hs(s,e,r),r.toArray()}var Gs=ke.serialize=fa;function bt(s,e,t,r){try{if(typeof t=="string")return r[`read${js(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return r.readFixedArray(t[0]);if(typeof t[1]=="number"){const n=[];for(let o=0;o<t[1];o++)n.push(bt(s,null,t[0],r));return n}else return r.readArray(()=>bt(s,e,t[0],r))}if(t.kind==="option")return r.readU8()?bt(s,e,t.type,r):void 0;if(t.kind==="map"){let n=new Map;const o=r.readU32();for(let i=0;i<o;i++){const a=bt(s,e,t.key,r),c=bt(s,e,t.value,r);n.set(a,c)}return n}return ln(s,t,r)}catch(n){throw n instanceof xe&&n.addToFieldPath(e),n}}function ln(s,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const r=s.get(e);if(!r)throw new xe(`Class ${e.name} is missing in schema`);if(r.kind==="struct"){const n={};for(const[o,i]of s.get(e).fields)n[o]=bt(s,o,i,t);return new e(n)}if(r.kind==="enum"){const n=t.readU8();if(n>=r.values.length)throw new xe(`Enum index: ${n} is out of range`);const[o,i]=r.values[n],a=bt(s,o,i,t);return new e({[o]:a})}throw new xe(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function ha(s,e,t,r=Ue){const n=new r(t),o=ln(s,e,n);if(n.offset<t.length)throw new xe(`Unexpected ${t.length-n.offset} bytes after deserialized data`);return o}var Ys=ke.deserialize=ha;function pa(s,e,t,r=Ue){const n=new r(t);return ln(s,e,n)}Fs=ke.deserializeUnchecked=pa;var y={};Object.defineProperty(y,"__esModule",{value:!0});y.s16=y.s8=y.nu64be=y.u48be=y.u40be=y.u32be=y.u24be=y.u16be=we=y.nu64=y.u48=y.u40=D=y.u32=y.u24=Ke=y.u16=Q=y.u8=ft=y.offset=y.greedy=y.Constant=y.UTF8=y.CString=y.Blob=y.Boolean=y.BitField=y.BitStructure=y.VariantLayout=y.Union=y.UnionLayoutDiscriminator=y.UnionDiscriminator=y.Structure=y.Sequence=y.DoubleBE=y.Double=y.FloatBE=y.Float=y.NearInt64BE=y.NearInt64=y.NearUInt64BE=y.NearUInt64=y.IntBE=y.Int=y.UIntBE=y.UInt=y.OffsetLayout=y.GreedyCount=y.ExternalLayout=y.bindConstructorLayout=y.nameWithProperty=y.Layout=y.uint8ArrayToBuffer=y.checkUint8Array=void 0;y.constant=y.utf8=y.cstr=ae=y.blob=y.unionLayoutDiscriminator=y.union=ve=y.seq=y.bits=q=y.struct=y.f64be=y.f64=y.f32be=y.f32=y.ns64be=y.s48be=y.s40be=y.s32be=y.s24be=y.s16be=ze=y.ns64=y.s48=y.s40=y.s32=y.s24=void 0;const dn=U;function Ut(s){if(!(s instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}y.checkUint8Array=Ut;function te(s){return Ut(s),dn.Buffer.from(s.buffer,s.byteOffset,s.length)}y.uint8ArrayToBuffer=te;class se{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}y.Layout=se;function fn(s,e){return e.property?s+"["+e.property+"]":s}y.nameWithProperty=fn;function ya(s,e){if(typeof s!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(s,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof se))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");s.layout_=e,e.boundConstructor_=s,e.makeDestinationObject=()=>new s,Object.defineProperty(s.prototype,"encode",{value(t,r){return e.encode(this,t,r)},writable:!0}),Object.defineProperty(s,"decode",{value(t,r){return e.decode(t,r)},writable:!0})}y.bindConstructorLayout=ya;class Le extends se{isCount(){throw new Error("ExternalLayout is abstract")}}y.ExternalLayout=Le;class Js extends Le{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Ut(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}y.GreedyCount=Js;class hn extends Le{constructor(e,t=0,r){if(!(e instanceof se))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof We||this.layout instanceof Me}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}y.OffsetLayout=hn;class We extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readUIntLE(t,this.span)}encode(e,t,r=0){return te(t).writeUIntLE(e,r,this.span),this.span}}y.UInt=We;class Me extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readUIntBE(t,this.span)}encode(e,t,r=0){return te(t).writeUIntBE(e,r,this.span),this.span}}y.UIntBE=Me;class vt extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readIntLE(t,this.span)}encode(e,t,r=0){return te(t).writeIntLE(e,r,this.span),this.span}}y.Int=vt;class Kt extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readIntBE(t,this.span)}encode(e,t,r=0){return te(t).writeIntBE(e,r,this.span),this.span}}y.IntBE=Kt;const Qr=Math.pow(2,32);function pr(s){const e=Math.floor(s/Qr),t=s-e*Qr;return{hi32:e,lo32:t}}function yr(s,e){return s*Qr+e}class Xs extends se{constructor(e){super(8,e)}decode(e,t=0){const r=te(e),n=r.readUInt32LE(t),o=r.readUInt32LE(t+4);return yr(o,n)}encode(e,t,r=0){const n=pr(e),o=te(t);return o.writeUInt32LE(n.lo32,r),o.writeUInt32LE(n.hi32,r+4),8}}y.NearUInt64=Xs;class Zs extends se{constructor(e){super(8,e)}decode(e,t=0){const r=te(e),n=r.readUInt32BE(t),o=r.readUInt32BE(t+4);return yr(n,o)}encode(e,t,r=0){const n=pr(e),o=te(t);return o.writeUInt32BE(n.hi32,r),o.writeUInt32BE(n.lo32,r+4),8}}y.NearUInt64BE=Zs;class Qs extends se{constructor(e){super(8,e)}decode(e,t=0){const r=te(e),n=r.readUInt32LE(t),o=r.readInt32LE(t+4);return yr(o,n)}encode(e,t,r=0){const n=pr(e),o=te(t);return o.writeUInt32LE(n.lo32,r),o.writeInt32LE(n.hi32,r+4),8}}y.NearInt64=Qs;class eo extends se{constructor(e){super(8,e)}decode(e,t=0){const r=te(e),n=r.readInt32BE(t),o=r.readUInt32BE(t+4);return yr(n,o)}encode(e,t,r=0){const n=pr(e),o=te(t);return o.writeInt32BE(n.hi32,r),o.writeUInt32BE(n.lo32,r+4),8}}y.NearInt64BE=eo;class to extends se{constructor(e){super(4,e)}decode(e,t=0){return te(e).readFloatLE(t)}encode(e,t,r=0){return te(t).writeFloatLE(e,r),4}}y.Float=to;class ro extends se{constructor(e){super(4,e)}decode(e,t=0){return te(e).readFloatBE(t)}encode(e,t,r=0){return te(t).writeFloatBE(e,r),4}}y.FloatBE=ro;class no extends se{constructor(e){super(8,e)}decode(e,t=0){return te(e).readDoubleLE(t)}encode(e,t,r=0){return te(t).writeDoubleLE(e,r),8}}y.Double=no;class so extends se{constructor(e){super(8,e)}decode(e,t=0){return te(e).readDoubleBE(t)}encode(e,t,r=0){return te(t).writeDoubleBE(e,r),8}}y.DoubleBE=so;class oo extends se{constructor(e,t,r){if(!(e instanceof se))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Le&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(t instanceof Le)&&0<e.span&&(n=t*e.span),super(n,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,n=this.count;if(n instanceof Le&&(n=n.decode(e,t)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let o=0;for(;o<n;)r+=this.elementLayout.getSpan(e,t+r),++o}return r}decode(e,t=0){const r=[];let n=0,o=this.count;for(o instanceof Le&&(o=o.decode(e,t));n<o;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),n+=1;return r}encode(e,t,r=0){const n=this.elementLayout,o=e.reduce((i,a)=>i+n.encode(a,t,r+i),0);return this.count instanceof Le&&this.count.encode(e.length,t,r),o}}y.Sequence=oo;class io extends se{constructor(e,t,r){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof se,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&r===void 0&&(r=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(n,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce((n,o)=>{const i=o.getSpan(e,t);return t+=i,n+i},0)}catch{throw new RangeError("indeterminate span")}return r}decode(e,t=0){Ut(e);const r=this.makeDestinationObject();for(const n of this.fields)if(n.property!==void 0&&(r[n.property]=n.decode(e,t)),t+=n.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const n=r;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const l=e[a.property];l!==void 0&&(i=a.encode(l,t,r),0>c&&(c=a.getSpan(t,r)))}o=r,r+=c}return o+i-n}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)r.property!==void 0&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}y.Structure=io;class pn{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}y.UnionDiscriminator=pn;class dr extends pn{constructor(e,t){if(!(e instanceof Le&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}y.UnionLayoutDiscriminator=dr;class yn extends se{constructor(e,t,r){let n;if(e instanceof We||e instanceof Me)n=new dr(new hn(e));else if(e instanceof Le&&e.isCount())n=new dr(e);else if(e instanceof pn)n=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof se))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof We||e instanceof Me)&&(o+=n.layout.span)),super(o,r),this.discriminator=n,this.usesPrefixDiscriminator=e instanceof We||e instanceof Me,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const n=this.discriminator,o=n.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=n.layout.span),r=this.makeDestinationObject(),r[n.property]=o,r[a.property]=a.decode(e,t+c)}else r=i.decode(e,t);return r}encode(e,t,r=0){const n=this.getSourceVariant(e);if(n===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,r),a+i.encode(e[i.property],t,r+a)}return n.encode(e,t,r)}addVariant(e,t,r){const n=new ao(this,e,t,r);return this.registry[e]=n,n}getVariant(e,t=0){let r;return e instanceof Uint8Array?r=this.discriminator.decode(e,t):r=e,this.registry[r]}}y.Union=yn;class ao extends se{constructor(e,t,r,n){if(!(e instanceof yn))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof r=="string"&&n===void 0&&(n=r,r=null),r){if(!(r instanceof se))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof n!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=r?r.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,n),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let n=0;return this.layout&&(n=this.layout.getSpan(e,t+r)),r+n}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+n):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let o=n;if(this.layout&&(this.layout.encode(e[this.property],t,r+n),o+=this.layout.getSpan(t,r+n),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}y.VariantLayout=ao;function Pt(s){return 0>s&&(s+=4294967296),s}class gn extends se{constructor(e,t,r){if(!(e instanceof We||e instanceof Me))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&r===void 0&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let n=0;this._packedSetValue=function(o){return n=Pt(o),this},this._packedGetValue=function(){return n}}decode(e,t=0){const r=this.makeDestinationObject(),n=this.word.decode(e,t);this._packedSetValue(n);for(const o of this.fields)o.property!==void 0&&(r[o.property]=o.decode(e));return r}encode(e,t,r=0){const n=this.word.decode(t,r);this._packedSetValue(n);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new bn(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new co(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}y.BitStructure=gn;class bn{constructor(e,t,r){if(!(e instanceof gn))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const n=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>n)throw new Error("bits too long for span remainder ("+(n-o)+" of "+n+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=n-o-t),this.wordMask=Pt(this.valueMask<<this.start),this.property=r}decode(e,t){const r=this.container._packedGetValue();return Pt(r&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Pt(e&this.valueMask))throw new TypeError(fn("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=Pt(e<<this.start);this.container._packedSetValue(Pt(t&~this.wordMask)|r)}}y.BitField=bn;let co=class extends bn{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};y.Boolean=co;class uo extends se{constructor(e,t){if(!(e instanceof Le&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof Le||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),te(e).slice(t,t+r)}encode(e,t,r){let n=this.length;if(this.length instanceof Le&&(n=e.length),!(e instanceof Uint8Array&&n===e.length))throw new TypeError(fn("Blob.encode",this)+" requires (length "+n+") Uint8Array as src");if(r+n>t.length)throw new RangeError("encoding overruns Uint8Array");const o=te(e);return te(t).write(o.toString("hex"),r,n,"hex"),this.length instanceof Le&&this.length.encode(n,t,r),n}}y.Blob=uo;class lo extends se{constructor(e){super(-1,e)}getSpan(e,t=0){Ut(e);let r=t;for(;r<e.length&&e[r]!==0;)r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return te(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const n=dn.Buffer.from(e,"utf8"),o=n.length;if(r+o>t.length)throw new RangeError("encoding overruns Buffer");const i=te(t);return n.copy(i,r),i[r+o]=0,o+1}}y.CString=lo;class fo extends se{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Ut(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return te(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const n=dn.Buffer.from(e,"utf8"),o=n.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return n.copy(te(t),r),o}}y.UTF8=fo;class ho extends se{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}y.Constant=ho;y.greedy=(s,e)=>new Js(s,e);var ft=y.offset=(s,e,t)=>new hn(s,e,t),Q=y.u8=s=>new We(1,s),Ke=y.u16=s=>new We(2,s);y.u24=s=>new We(3,s);var D=y.u32=s=>new We(4,s);y.u40=s=>new We(5,s);y.u48=s=>new We(6,s);var we=y.nu64=s=>new Xs(s);y.u16be=s=>new Me(2,s);y.u24be=s=>new Me(3,s);y.u32be=s=>new Me(4,s);y.u40be=s=>new Me(5,s);y.u48be=s=>new Me(6,s);y.nu64be=s=>new Zs(s);y.s8=s=>new vt(1,s);y.s16=s=>new vt(2,s);y.s24=s=>new vt(3,s);y.s32=s=>new vt(4,s);y.s40=s=>new vt(5,s);y.s48=s=>new vt(6,s);var ze=y.ns64=s=>new Qs(s);y.s16be=s=>new Kt(2,s);y.s24be=s=>new Kt(3,s);y.s32be=s=>new Kt(4,s);y.s40be=s=>new Kt(5,s);y.s48be=s=>new Kt(6,s);y.ns64be=s=>new eo(s);y.f32=s=>new to(s);y.f32be=s=>new ro(s);y.f64=s=>new no(s);y.f64be=s=>new so(s);var q=y.struct=(s,e,t)=>new io(s,e,t);y.bits=(s,e,t)=>new gn(s,e,t);var ve=y.seq=(s,e,t)=>new oo(s,e,t);y.union=(s,e,t)=>new yn(s,e,t);y.unionLayoutDiscriminator=(s,e)=>new dr(s,e);var ae=y.blob=(s,e)=>new uo(s,e);y.cstr=s=>new lo(s);y.utf8=(s,e)=>new fo(s,e);y.constant=(s,e)=>new ho(s,e);var Jt={};Object.defineProperty(Jt,"__esModule",{value:!0});function ga(s){{const e=U.Buffer.from(s);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var ba=Jt.toBigIntLE=ga;function ma(s){{const e=s.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Jt.toBigIntBE=ma;function wa(s,e){{const t=s.toString(16),r=U.Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return r.reverse(),r}}var po=Jt.toBufferLE=wa;function ka(s,e){{const t=s.toString(16);return U.Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Jt.toBufferBE=ka;class Sa extends TypeError{constructor(e,t){let r;const{message:n,...o}=e,{path:i}=e,a=i.length===0?n:"At path: "+i.join(".")+" -- "+n;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=r)!=null?c:r=[e,...t()]}}}function va(s){return ht(s)&&typeof s[Symbol.iterator]=="function"}function ht(s){return typeof s=="object"&&s!=null}function Fe(s){return typeof s=="string"?JSON.stringify(s):""+s}function Ia(s){const{done:e,value:t}=s.next();return e?void 0:t}function _a(s,e,t,r){if(s===!0)return;s===!1?s={}:typeof s=="string"&&(s={message:s});const{path:n,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+Fe(r)+"`"}=s;return{value:r,type:i,refinement:a,key:n[n.length-1],path:n,branch:o,...s,message:c}}function*is(s,e,t,r){va(s)||(s=[s]);for(const n of s){const o=_a(n,e,t,r);o&&(yield o)}}function*mn(s,e,t={}){const{path:r=[],branch:n=[s],coerce:o=!1,mask:i=!1}=t,a={path:r,branch:n};if(o&&(s=e.coercer(s,a),i&&e.type!=="type"&&ht(e.schema)&&ht(s)&&!Array.isArray(s)))for(const l in s)e.schema[l]===void 0&&delete s[l];let c=!0;for(const l of e.validator(s,a))c=!1,yield[l,void 0];for(let[l,u,p]of e.entries(s,a)){const k=mn(u,p,{path:l===void 0?r:[...r,l],branch:l===void 0?n:[...n,u],coerce:o,mask:i});for(const d of k)d[0]?(c=!1,yield[d[0],void 0]):o&&(u=d[1],l===void 0?s=u:s instanceof Map?s.set(l,u):s instanceof Set?s.add(u):ht(s)&&(s[l]=u))}if(c)for(const l of e.refiner(s,a))c=!1,yield[l,void 0];c&&(yield[void 0,s])}let rt=class{constructor(e){const{type:t,schema:r,validator:n,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=i,n?this.validator=(c,l)=>{const u=n(c,l);return is(u,l,this,c)}:this.validator=()=>[],o?this.refiner=(c,l)=>{const u=o(c,l);return is(u,l,this,c)}:this.refiner=()=>[]}assert(e){return yo(e,this)}create(e){return T(e,this)}is(e){return go(e,this)}mask(e){return Aa(e,this)}validate(e,t={}){return Xt(e,this,t)}};function yo(s,e){const t=Xt(s,e);if(t[0])throw t[0]}function T(s,e){const t=Xt(s,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function Aa(s,e){const t=Xt(s,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function go(s,e){return!Xt(s,e)[0]}function Xt(s,e,t={}){const r=mn(s,e,t),n=Ia(r);return n[0]?[new Sa(n[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0]:[void 0,n[1]]}function It(s,e){return new rt({type:s,schema:null,validator:e})}function Ea(){return It("any",()=>!0)}function N(s){return new rt({type:"array",schema:s,*entries(e){if(s&&Array.isArray(e))for(const[t,r]of e.entries())yield[t,r,s]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+Fe(e)}})}function Qe(){return It("boolean",s=>typeof s=="boolean")}function wn(s){return It("instance",e=>e instanceof s||"Expected a `"+s.name+"` instance, but received: "+Fe(e))}function fe(s){const e=Fe(s),t=typeof s;return new rt({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?s:null,validator(r){return r===s||"Expected the literal `"+e+"`, but received: "+Fe(r)}})}function Ra(){return It("never",()=>!1)}function O(s){return new rt({...s,validator:(e,t)=>e===null||s.validator(e,t),refiner:(e,t)=>e===null||s.refiner(e,t)})}function f(){return It("number",s=>typeof s=="number"&&!isNaN(s)||"Expected a number, but received: "+Fe(s))}function V(s){return new rt({...s,validator:(e,t)=>e===void 0||s.validator(e,t),refiner:(e,t)=>e===void 0||s.refiner(e,t)})}function bo(s,e){return new rt({type:"record",schema:null,*entries(t){if(ht(t))for(const r in t){const n=t[r];yield[r,r,s],yield[r,n,e]}},validator(t){return ht(t)||"Expected an object, but received: "+Fe(t)}})}function x(){return It("string",s=>typeof s=="string"||"Expected a string, but received: "+Fe(s))}function kn(s){const e=Ra();return new rt({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(s.length,t.length);for(let n=0;n<r;n++)yield[n,t[n],s[n]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+Fe(t)}})}function E(s){const e=Object.keys(s);return new rt({type:"type",schema:s,*entries(t){if(ht(t))for(const r of e)yield[r,t[r],s[r]]},validator(t){return ht(t)||"Expected an object, but received: "+Fe(t)}})}function Ce(s){const e=s.map(t=>t.type).join(" | ");return new rt({type:"union",schema:null,validator(t,r){const n=[];for(const o of s){const[...i]=mn(t,o,r),[a]=i;if(a[0])for(const[c]of i)c&&n.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+Fe(t),...n]}})}function Zt(){return It("unknown",()=>!0)}function Qt(s,e,t){return new rt({...s,coercer:(r,n)=>go(r,e)?s.coercer(t(r,n),n):s.coercer(r,n)})}var ar,xa=new Uint8Array(16);function mo(){if(!ar&&(ar=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!ar))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return ar(xa)}const Ba=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function gr(s){return typeof s=="string"&&Ba.test(s)}var me=[];for(var Br=0;Br<256;++Br)me.push((Br+256).toString(16).substr(1));function br(s){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(me[s[e+0]]+me[s[e+1]]+me[s[e+2]]+me[s[e+3]]+"-"+me[s[e+4]]+me[s[e+5]]+"-"+me[s[e+6]]+me[s[e+7]]+"-"+me[s[e+8]]+me[s[e+9]]+"-"+me[s[e+10]]+me[s[e+11]]+me[s[e+12]]+me[s[e+13]]+me[s[e+14]]+me[s[e+15]]).toLowerCase();if(!gr(t))throw TypeError("Stringified UUID is invalid");return t}var as,Pr,Tr=0,Lr=0;function Pa(s,e,t){var r=e&&t||0,n=e||new Array(16);s=s||{};var o=s.node||as,i=s.clockseq!==void 0?s.clockseq:Pr;if(o==null||i==null){var a=s.random||(s.rng||mo)();o==null&&(o=as=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=Pr=(a[6]<<8|a[7])&16383)}var c=s.msecs!==void 0?s.msecs:Date.now(),l=s.nsecs!==void 0?s.nsecs:Lr+1,u=c-Tr+(l-Lr)/1e4;if(u<0&&s.clockseq===void 0&&(i=i+1&16383),(u<0||c>Tr)&&s.nsecs===void 0&&(l=0),l>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Tr=c,Lr=l,Pr=i,c+=122192928e5;var p=((c&268435455)*1e4+l)%4294967296;n[r++]=p>>>24&255,n[r++]=p>>>16&255,n[r++]=p>>>8&255,n[r++]=p&255;var k=c/4294967296*1e4&268435455;n[r++]=k>>>8&255,n[r++]=k&255,n[r++]=k>>>24&15|16,n[r++]=k>>>16&255,n[r++]=i>>>8|128,n[r++]=i&255;for(var d=0;d<6;++d)n[r+d]=o[d];return e||br(n)}function wo(s){if(!gr(s))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(s.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(s.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(s.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(s.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(s.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function Ta(s){s=unescape(encodeURIComponent(s));for(var e=[],t=0;t<s.length;++t)e.push(s.charCodeAt(t));return e}var La="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Ca="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function ko(s,e,t){function r(n,o,i,a){if(typeof n=="string"&&(n=Ta(n)),typeof o=="string"&&(o=wo(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+n.length);if(c.set(o),c.set(n,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var l=0;l<16;++l)i[a+l]=c[l];return i}return br(c)}try{r.name=s}catch{}return r.DNS=La,r.URL=Ca,r}function Oa(s){if(typeof s=="string"){var e=unescape(encodeURIComponent(s));s=new Uint8Array(e.length);for(var t=0;t<e.length;++t)s[t]=e.charCodeAt(t)}return za(Na(Ua(s),s.length*8))}function za(s){for(var e=[],t=s.length*32,r="0123456789abcdef",n=0;n<t;n+=8){var o=s[n>>5]>>>n%32&255,i=parseInt(r.charAt(o>>>4&15)+r.charAt(o&15),16);e.push(i)}return e}function So(s){return(s+64>>>9<<4)+14+1}function Na(s,e){s[e>>5]|=128<<e%32,s[So(e)-1]=e;for(var t=1732584193,r=-271733879,n=-1732584194,o=271733878,i=0;i<s.length;i+=16){var a=t,c=r,l=n,u=o;t=_e(t,r,n,o,s[i],7,-680876936),o=_e(o,t,r,n,s[i+1],12,-389564586),n=_e(n,o,t,r,s[i+2],17,606105819),r=_e(r,n,o,t,s[i+3],22,-1044525330),t=_e(t,r,n,o,s[i+4],7,-176418897),o=_e(o,t,r,n,s[i+5],12,1200080426),n=_e(n,o,t,r,s[i+6],17,-1473231341),r=_e(r,n,o,t,s[i+7],22,-45705983),t=_e(t,r,n,o,s[i+8],7,1770035416),o=_e(o,t,r,n,s[i+9],12,-1958414417),n=_e(n,o,t,r,s[i+10],17,-42063),r=_e(r,n,o,t,s[i+11],22,-1990404162),t=_e(t,r,n,o,s[i+12],7,1804603682),o=_e(o,t,r,n,s[i+13],12,-40341101),n=_e(n,o,t,r,s[i+14],17,-1502002290),r=_e(r,n,o,t,s[i+15],22,1236535329),t=Ae(t,r,n,o,s[i+1],5,-165796510),o=Ae(o,t,r,n,s[i+6],9,-1069501632),n=Ae(n,o,t,r,s[i+11],14,643717713),r=Ae(r,n,o,t,s[i],20,-373897302),t=Ae(t,r,n,o,s[i+5],5,-701558691),o=Ae(o,t,r,n,s[i+10],9,38016083),n=Ae(n,o,t,r,s[i+15],14,-660478335),r=Ae(r,n,o,t,s[i+4],20,-405537848),t=Ae(t,r,n,o,s[i+9],5,568446438),o=Ae(o,t,r,n,s[i+14],9,-1019803690),n=Ae(n,o,t,r,s[i+3],14,-187363961),r=Ae(r,n,o,t,s[i+8],20,1163531501),t=Ae(t,r,n,o,s[i+13],5,-1444681467),o=Ae(o,t,r,n,s[i+2],9,-51403784),n=Ae(n,o,t,r,s[i+7],14,1735328473),r=Ae(r,n,o,t,s[i+12],20,-1926607734),t=Ee(t,r,n,o,s[i+5],4,-378558),o=Ee(o,t,r,n,s[i+8],11,-2022574463),n=Ee(n,o,t,r,s[i+11],16,1839030562),r=Ee(r,n,o,t,s[i+14],23,-35309556),t=Ee(t,r,n,o,s[i+1],4,-1530992060),o=Ee(o,t,r,n,s[i+4],11,1272893353),n=Ee(n,o,t,r,s[i+7],16,-155497632),r=Ee(r,n,o,t,s[i+10],23,-1094730640),t=Ee(t,r,n,o,s[i+13],4,681279174),o=Ee(o,t,r,n,s[i],11,-358537222),n=Ee(n,o,t,r,s[i+3],16,-722521979),r=Ee(r,n,o,t,s[i+6],23,76029189),t=Ee(t,r,n,o,s[i+9],4,-640364487),o=Ee(o,t,r,n,s[i+12],11,-421815835),n=Ee(n,o,t,r,s[i+15],16,530742520),r=Ee(r,n,o,t,s[i+2],23,-995338651),t=Re(t,r,n,o,s[i],6,-198630844),o=Re(o,t,r,n,s[i+7],10,1126891415),n=Re(n,o,t,r,s[i+14],15,-1416354905),r=Re(r,n,o,t,s[i+5],21,-57434055),t=Re(t,r,n,o,s[i+12],6,1700485571),o=Re(o,t,r,n,s[i+3],10,-1894986606),n=Re(n,o,t,r,s[i+10],15,-1051523),r=Re(r,n,o,t,s[i+1],21,-2054922799),t=Re(t,r,n,o,s[i+8],6,1873313359),o=Re(o,t,r,n,s[i+15],10,-30611744),n=Re(n,o,t,r,s[i+6],15,-1560198380),r=Re(r,n,o,t,s[i+13],21,1309151649),t=Re(t,r,n,o,s[i+4],6,-145523070),o=Re(o,t,r,n,s[i+11],10,-1120210379),n=Re(n,o,t,r,s[i+2],15,718787259),r=Re(r,n,o,t,s[i+9],21,-343485551),t=dt(t,a),r=dt(r,c),n=dt(n,l),o=dt(o,u)}return[t,r,n,o]}function Ua(s){if(s.length===0)return[];for(var e=s.length*8,t=new Uint32Array(So(e)),r=0;r<e;r+=8)t[r>>5]|=(s[r/8]&255)<<r%32;return t}function dt(s,e){var t=(s&65535)+(e&65535),r=(s>>16)+(e>>16)+(t>>16);return r<<16|t&65535}function Ka(s,e){return s<<e|s>>>32-e}function mr(s,e,t,r,n,o){return dt(Ka(dt(dt(e,s),dt(r,o)),n),t)}function _e(s,e,t,r,n,o,i){return mr(e&t|~e&r,s,e,n,o,i)}function Ae(s,e,t,r,n,o,i){return mr(e&r|t&~r,s,e,n,o,i)}function Ee(s,e,t,r,n,o,i){return mr(e^t^r,s,e,n,o,i)}function Re(s,e,t,r,n,o,i){return mr(t^(e|~r),s,e,n,o,i)}var Wa=ko("v3",48,Oa);const Da=Wa;function qa(s,e,t){s=s||{};var r=s.random||(s.rng||mo)();if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,e){t=t||0;for(var n=0;n<16;++n)e[t+n]=r[n];return e}return br(r)}function Ma(s,e,t,r){switch(s){case 0:return e&t^~e&r;case 1:return e^t^r;case 2:return e&t^e&r^t&r;case 3:return e^t^r}}function Cr(s,e){return s<<e|s>>>32-e}function Fa(s){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof s=="string"){var r=unescape(encodeURIComponent(s));s=[];for(var n=0;n<r.length;++n)s.push(r.charCodeAt(n))}else Array.isArray(s)||(s=Array.prototype.slice.call(s));s.push(128);for(var o=s.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var l=new Uint32Array(16),u=0;u<16;++u)l[u]=s[c*64+u*4]<<24|s[c*64+u*4+1]<<16|s[c*64+u*4+2]<<8|s[c*64+u*4+3];a[c]=l}a[i-1][14]=(s.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(s.length-1)*8&4294967295;for(var p=0;p<i;++p){for(var k=new Uint32Array(80),d=0;d<16;++d)k[d]=a[p][d];for(var b=16;b<80;++b)k[b]=Cr(k[b-3]^k[b-8]^k[b-14]^k[b-16],1);for(var w=t[0],h=t[1],I=t[2],R=t[3],v=t[4],A=0;A<80;++A){var B=Math.floor(A/20),_=Cr(w,5)+Ma(B,h,I,R)+v+e[B]+k[A]>>>0;v=R,R=I,I=Cr(h,30)>>>0,h=w,w=_}t[0]=t[0]+w>>>0,t[1]=t[1]+h>>>0,t[2]=t[2]+I>>>0,t[3]=t[3]+R>>>0,t[4]=t[4]+v>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Va=ko("v5",80,Fa);const $a=Va,ja="00000000-0000-0000-0000-000000000000";function Ha(s){if(!gr(s))throw TypeError("Invalid UUID");return parseInt(s.substr(14,1),16)}const Ga=Object.freeze(Object.defineProperty({__proto__:null,NIL:ja,parse:wo,stringify:br,v1:Pa,v3:Da,v4:qa,v5:$a,validate:gr,version:Ha},Symbol.toStringTag,{value:"Module"})),vo=hi(Ga),Ya=vo.v4,Ja=function(s,e,t,r){if(typeof s!="string")throw new TypeError(s+" must be a string");r=r||{};const n=typeof r.version=="number"?r.version:2;if(n!==1&&n!==2)throw new TypeError(n+" must be 1 or 2");const o={method:s};if(n===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof r.generator=="function"?r.generator:function(){return Ya()};o.id=i(o,r)}else n===2&&t===null?r.notificationIdNull&&(o.id=null):o.id=t;return o};var Xa=Ja;const Za=vo.v4,Qa=Xa,$t=function(s,e){if(!(this instanceof $t))return new $t(s,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Za()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=s};var ec=$t;$t.prototype.request=function(s,e,t,r){const n=this;let o=null;const i=Array.isArray(s)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&s&&typeof s=="object"&&typeof e=="function")r=e,o=s;else{typeof t=="function"&&(r=t,t=void 0);const l=typeof r=="function";try{o=Qa(s,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(u){if(l)return r(u);throw u}if(!l)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(l){return r(l)}return this.callServer(c,function(l,u){n._parseResponse(l,u,r)}),o};$t.prototype._parseResponse=function(s,e,t){if(s){t(s);return}if(!e)return t();let r;try{r=JSON.parse(e,this.options.reviver)}catch(n){return t(n)}if(t.length===3)if(Array.isArray(r)){const n=function(i){return typeof i.error<"u"},o=function(i){return!n(i)};return t(null,r.filter(n),r.filter(o))}else return t(null,r.error,r.result);t(null,r)};const tc=Yt(ec);var Io={},_o={exports:{}};(function(s){function e(t){return t&&t.__esModule?t:{default:t}}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports})(_o);var Sn=_o.exports,Or={exports:{}},zr={exports:{}},cs;function er(){return cs||(cs=1,function(s){function e(t){"@babel/helpers - typeof";return s.exports=e=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(r){return typeof r}:function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},s.exports.__esModule=!0,s.exports.default=s.exports,e(t)}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(zr)),zr.exports}var us;function rc(){return us||(us=1,function(s){var e=er().default;function t(){s.exports=t=function(){return n},s.exports.__esModule=!0,s.exports.default=s.exports;var r,n={},o=Object.prototype,i=o.hasOwnProperty,a=Object.defineProperty||function(g,m,S){g[m]=S.value},c=typeof Symbol=="function"?Symbol:{},l=c.iterator||"@@iterator",u=c.asyncIterator||"@@asyncIterator",p=c.toStringTag||"@@toStringTag";function k(g,m,S){return Object.defineProperty(g,m,{value:S,enumerable:!0,configurable:!0,writable:!0}),g[m]}try{k({},"")}catch{k=function(S,L,z){return S[L]=z}}function d(g,m,S,L){var z=m&&m.prototype instanceof A?m:A,C=Object.create(z.prototype),j=new xt(L||[]);return a(C,"_invoke",{value:De(g,S,j)}),C}function b(g,m,S){try{return{type:"normal",arg:g.call(m,S)}}catch(L){return{type:"throw",arg:L}}}n.wrap=d;var w="suspendedStart",h="suspendedYield",I="executing",R="completed",v={};function A(){}function B(){}function _(){}var W={};k(W,l,function(){return this});var K=Object.getPrototypeOf,$=K&&K(K(F([])));$&&$!==o&&i.call($,l)&&(W=$);var le=_.prototype=A.prototype=Object.create(W);function Ie(g){["next","throw","return"].forEach(function(m){k(g,m,function(S){return this._invoke(m,S)})})}function $e(g,m){function S(z,C,j,H){var J=b(g[z],g,C);if(J.type!=="throw"){var ce=J.arg,de=ce.value;return de&&e(de)=="object"&&i.call(de,"__await")?m.resolve(de.__await).then(function(ye){S("next",ye,j,H)},function(ye){S("throw",ye,j,H)}):m.resolve(de).then(function(ye){ce.value=ye,j(ce)},function(ye){return S("throw",ye,j,H)})}H(J.arg)}var L;a(this,"_invoke",{value:function(C,j){function H(){return new m(function(J,ce){S(C,j,J,ce)})}return L=L?L.then(H,H):H()}})}function De(g,m,S){var L=w;return function(z,C){if(L===I)throw Error("Generator is already running");if(L===R){if(z==="throw")throw C;return{value:r,done:!0}}for(S.method=z,S.arg=C;;){var j=S.delegate;if(j){var H=Et(j,S);if(H){if(H===v)continue;return H}}if(S.method==="next")S.sent=S._sent=S.arg;else if(S.method==="throw"){if(L===w)throw L=R,S.arg;S.dispatchException(S.arg)}else S.method==="return"&&S.abrupt("return",S.arg);L=I;var J=b(g,m,S);if(J.type==="normal"){if(L=S.done?R:h,J.arg===v)continue;return{value:J.arg,done:S.done}}J.type==="throw"&&(L=R,S.method="throw",S.arg=J.arg)}}}function Et(g,m){var S=m.method,L=g.iterator[S];if(L===r)return m.delegate=null,S==="throw"&&g.iterator.return&&(m.method="return",m.arg=r,Et(g,m),m.method==="throw")||S!=="return"&&(m.method="throw",m.arg=new TypeError("The iterator does not provide a '"+S+"' method")),v;var z=b(L,g.iterator,m.arg);if(z.type==="throw")return m.method="throw",m.arg=z.arg,m.delegate=null,v;var C=z.arg;return C?C.done?(m[g.resultName]=C.value,m.next=g.nextLoc,m.method!=="return"&&(m.method="next",m.arg=r),m.delegate=null,v):C:(m.method="throw",m.arg=new TypeError("iterator result is not an object"),m.delegate=null,v)}function Rt(g){var m={tryLoc:g[0]};1 in g&&(m.catchLoc=g[1]),2 in g&&(m.finallyLoc=g[2],m.afterLoc=g[3]),this.tryEntries.push(m)}function yt(g){var m=g.completion||{};m.type="normal",delete m.arg,g.completion=m}function xt(g){this.tryEntries=[{tryLoc:"root"}],g.forEach(Rt,this),this.reset(!0)}function F(g){if(g||g===""){var m=g[l];if(m)return m.call(g);if(typeof g.next=="function")return g;if(!isNaN(g.length)){var S=-1,L=function z(){for(;++S<g.length;)if(i.call(g,S))return z.value=g[S],z.done=!1,z;return z.value=r,z.done=!0,z};return L.next=L}}throw new TypeError(e(g)+" is not iterable")}return B.prototype=_,a(le,"constructor",{value:_,configurable:!0}),a(_,"constructor",{value:B,configurable:!0}),B.displayName=k(_,p,"GeneratorFunction"),n.isGeneratorFunction=function(g){var m=typeof g=="function"&&g.constructor;return!!m&&(m===B||(m.displayName||m.name)==="GeneratorFunction")},n.mark=function(g){return Object.setPrototypeOf?Object.setPrototypeOf(g,_):(g.__proto__=_,k(g,p,"GeneratorFunction")),g.prototype=Object.create(le),g},n.awrap=function(g){return{__await:g}},Ie($e.prototype),k($e.prototype,u,function(){return this}),n.AsyncIterator=$e,n.async=function(g,m,S,L,z){z===void 0&&(z=Promise);var C=new $e(d(g,m,S,L),z);return n.isGeneratorFunction(m)?C:C.next().then(function(j){return j.done?j.value:C.next()})},Ie(le),k(le,p,"Generator"),k(le,l,function(){return this}),k(le,"toString",function(){return"[object Generator]"}),n.keys=function(g){var m=Object(g),S=[];for(var L in m)S.push(L);return S.reverse(),function z(){for(;S.length;){var C=S.pop();if(C in m)return z.value=C,z.done=!1,z}return z.done=!0,z}},n.values=F,xt.prototype={constructor:xt,reset:function(m){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next",this.arg=r,this.tryEntries.forEach(yt),!m)for(var S in this)S.charAt(0)==="t"&&i.call(this,S)&&!isNaN(+S.slice(1))&&(this[S]=r)},stop:function(){this.done=!0;var m=this.tryEntries[0].completion;if(m.type==="throw")throw m.arg;return this.rval},dispatchException:function(m){if(this.done)throw m;var S=this;function L(ce,de){return j.type="throw",j.arg=m,S.next=ce,de&&(S.method="next",S.arg=r),!!de}for(var z=this.tryEntries.length-1;z>=0;--z){var C=this.tryEntries[z],j=C.completion;if(C.tryLoc==="root")return L("end");if(C.tryLoc<=this.prev){var H=i.call(C,"catchLoc"),J=i.call(C,"finallyLoc");if(H&&J){if(this.prev<C.catchLoc)return L(C.catchLoc,!0);if(this.prev<C.finallyLoc)return L(C.finallyLoc)}else if(H){if(this.prev<C.catchLoc)return L(C.catchLoc,!0)}else{if(!J)throw Error("try statement without catch or finally");if(this.prev<C.finallyLoc)return L(C.finallyLoc)}}}},abrupt:function(m,S){for(var L=this.tryEntries.length-1;L>=0;--L){var z=this.tryEntries[L];if(z.tryLoc<=this.prev&&i.call(z,"finallyLoc")&&this.prev<z.finallyLoc){var C=z;break}}C&&(m==="break"||m==="continue")&&C.tryLoc<=S&&S<=C.finallyLoc&&(C=null);var j=C?C.completion:{};return j.type=m,j.arg=S,C?(this.method="next",this.next=C.finallyLoc,v):this.complete(j)},complete:function(m,S){if(m.type==="throw")throw m.arg;return m.type==="break"||m.type==="continue"?this.next=m.arg:m.type==="return"?(this.rval=this.arg=m.arg,this.method="return",this.next="end"):m.type==="normal"&&S&&(this.next=S),v},finish:function(m){for(var S=this.tryEntries.length-1;S>=0;--S){var L=this.tryEntries[S];if(L.finallyLoc===m)return this.complete(L.completion,L.afterLoc),yt(L),v}},catch:function(m){for(var S=this.tryEntries.length-1;S>=0;--S){var L=this.tryEntries[S];if(L.tryLoc===m){var z=L.completion;if(z.type==="throw"){var C=z.arg;yt(L)}return C}}throw Error("illegal catch attempt")},delegateYield:function(m,S,L){return this.delegate={iterator:F(m),resultName:S,nextLoc:L},this.method==="next"&&(this.arg=r),v}},n}s.exports=t,s.exports.__esModule=!0,s.exports.default=s.exports}(Or)),Or.exports}var Nr,ls;function nc(){if(ls)return Nr;ls=1;var s=rc()();Nr=s;try{regeneratorRuntime=s}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=s:Function("r","regeneratorRuntime = r")(s)}return Nr}var Ur={exports:{}},ds;function sc(){return ds||(ds=1,function(s){function e(r,n,o,i,a,c,l){try{var u=r[c](l),p=u.value}catch(k){o(k);return}u.done?n(p):Promise.resolve(p).then(i,a)}function t(r){return function(){var n=this,o=arguments;return new Promise(function(i,a){var c=r.apply(n,o);function l(p){e(c,i,a,l,u,"next",p)}function u(p){e(c,i,a,l,u,"throw",p)}l(void 0)})}}s.exports=t,s.exports.__esModule=!0,s.exports.default=s.exports}(Ur)),Ur.exports}var Kr={exports:{}},fs;function vn(){return fs||(fs=1,function(s){function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(Kr)),Kr.exports}var Wr={exports:{}},Dr={exports:{}},qr={exports:{}},hs;function oc(){return hs||(hs=1,function(s){var e=er().default;function t(r,n){if(e(r)!="object"||!r)return r;var o=r[Symbol.toPrimitive];if(o!==void 0){var i=o.call(r,n||"default");if(e(i)!="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(n==="string"?String:Number)(r)}s.exports=t,s.exports.__esModule=!0,s.exports.default=s.exports}(qr)),qr.exports}var ps;function ic(){return ps||(ps=1,function(s){var e=er().default,t=oc();function r(n){var o=t(n,"string");return e(o)=="symbol"?o:o+""}s.exports=r,s.exports.__esModule=!0,s.exports.default=s.exports}(Dr)),Dr.exports}var ys;function In(){return ys||(ys=1,function(s){var e=ic();function t(n,o){for(var i=0;i<o.length;i++){var a=o[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,e(a.key),a)}}function r(n,o,i){return o&&t(n.prototype,o),i&&t(n,i),Object.defineProperty(n,"prototype",{writable:!1}),n}s.exports=r,s.exports.__esModule=!0,s.exports.default=s.exports}(Wr)),Wr.exports}var Mr={exports:{}},Fr={exports:{}},gs;function ac(){return gs||(gs=1,function(s){function e(t,r){return s.exports=e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(o,i){return o.__proto__=i,o},s.exports.__esModule=!0,s.exports.default=s.exports,e(t,r)}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(Fr)),Fr.exports}var bs;function Ao(){return bs||(bs=1,function(s){var e=ac();function t(r,n){if(typeof n!="function"&&n!==null)throw new TypeError("Super expression must either be null or a function");r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,writable:!0,configurable:!0}}),Object.defineProperty(r,"prototype",{writable:!1}),n&&e(r,n)}s.exports=t,s.exports.__esModule=!0,s.exports.default=s.exports}(Mr)),Mr.exports}var Vr={exports:{}},$r={exports:{}},ms;function cc(){return ms||(ms=1,function(s){function e(t){if(t===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}($r)),$r.exports}var ws;function Eo(){return ws||(ws=1,function(s){var e=er().default,t=cc();function r(n,o){if(o&&(e(o)==="object"||typeof o=="function"))return o;if(o!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return t(n)}s.exports=r,s.exports.__esModule=!0,s.exports.default=s.exports}(Vr)),Vr.exports}var jr={exports:{}},ks;function Ro(){return ks||(ks=1,function(s){function e(t){return s.exports=e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},s.exports.__esModule=!0,s.exports.default=s.exports,e(t)}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(jr)),jr.exports}var xo={exports:{}};(function(s){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function n(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function o(c,l,u,p,k){if(typeof u!="function")throw new TypeError("The listener must be a function");var d=new n(u,p||c,k),b=t?t+l:l;return c._events[b]?c._events[b].fn?c._events[b]=[c._events[b],d]:c._events[b].push(d):(c._events[b]=d,c._eventsCount++),c}function i(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,p;if(this._eventsCount===0)return l;for(p in u=this._events)e.call(u,p)&&l.push(t?p.slice(1):p);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,p=this._events[u];if(!p)return[];if(p.fn)return[p.fn];for(var k=0,d=p.length,b=new Array(d);k<d;k++)b[k]=p[k].fn;return b},a.prototype.listenerCount=function(l){var u=t?t+l:l,p=this._events[u];return p?p.fn?1:p.length:0},a.prototype.emit=function(l,u,p,k,d,b){var w=t?t+l:l;if(!this._events[w])return!1;var h=this._events[w],I=arguments.length,R,v;if(h.fn){switch(h.once&&this.removeListener(l,h.fn,void 0,!0),I){case 1:return h.fn.call(h.context),!0;case 2:return h.fn.call(h.context,u),!0;case 3:return h.fn.call(h.context,u,p),!0;case 4:return h.fn.call(h.context,u,p,k),!0;case 5:return h.fn.call(h.context,u,p,k,d),!0;case 6:return h.fn.call(h.context,u,p,k,d,b),!0}for(v=1,R=new Array(I-1);v<I;v++)R[v-1]=arguments[v];h.fn.apply(h.context,R)}else{var A=h.length,B;for(v=0;v<A;v++)switch(h[v].once&&this.removeListener(l,h[v].fn,void 0,!0),I){case 1:h[v].fn.call(h[v].context);break;case 2:h[v].fn.call(h[v].context,u);break;case 3:h[v].fn.call(h[v].context,u,p);break;case 4:h[v].fn.call(h[v].context,u,p,k);break;default:if(!R)for(B=1,R=new Array(I-1);B<I;B++)R[B-1]=arguments[B];h[v].fn.apply(h[v].context,R)}}return!0},a.prototype.on=function(l,u,p){return o(this,l,u,p,!1)},a.prototype.once=function(l,u,p){return o(this,l,u,p,!0)},a.prototype.removeListener=function(l,u,p,k){var d=t?t+l:l;if(!this._events[d])return this;if(!u)return i(this,d),this;var b=this._events[d];if(b.fn)b.fn===u&&(!k||b.once)&&(!p||b.context===p)&&i(this,d);else{for(var w=0,h=[],I=b.length;w<I;w++)(b[w].fn!==u||k&&!b[w].once||p&&b[w].context!==p)&&h.push(b[w]);h.length?this._events[d]=h.length===1?h[0]:h:i(this,d)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&i(this,u)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,s.exports=a})(xo);var _n=xo.exports;const $l=Yt(_n);var Bt={},Ss;function uc(){if(Ss)return Bt;Ss=1;var s=Sn;Object.defineProperty(Bt,"__esModule",{value:!0}),Bt.DefaultDataPack=void 0,Bt.createError=o;var e=s(vn()),t=s(In()),r=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]),n=function(){function i(){(0,e.default)(this,i)}return(0,t.default)(i,[{key:"encode",value:function(c){return JSON.stringify(c)}},{key:"decode",value:function(c){return JSON.parse(c)}}]),i}();Bt.DefaultDataPack=n;function o(i,a){var c={code:i,message:r.get(i)||"Internal Server Error"};return a&&(c.data=a),c}return Bt}(function(s){var e=Sn;Object.defineProperty(s,"__esModule",{value:!0}),s.default=void 0;var t=e(nc()),r=e(sc()),n=e(er()),o=e(vn()),i=e(In()),a=e(Ao()),c=e(Eo()),l=e(Ro()),u=_n,p=uc();function k(h){var I=d();return function(){var v=(0,l.default)(h),A;if(I){var B=(0,l.default)(this).constructor;A=Reflect.construct(v,arguments,B)}else A=v.apply(this,arguments);return(0,c.default)(this,A)}}function d(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var b=function(h,I){var R={};for(var v in h)Object.prototype.hasOwnProperty.call(h,v)&&I.indexOf(v)<0&&(R[v]=h[v]);if(h!=null&&typeof Object.getOwnPropertySymbols=="function")for(var A=0,v=Object.getOwnPropertySymbols(h);A<v.length;A++)I.indexOf(v[A])<0&&Object.prototype.propertyIsEnumerable.call(h,v[A])&&(R[v[A]]=h[v[A]]);return R},w=function(h){(0,a.default)(R,h);var I=k(R);function R(v){var A,B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",_=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},W=arguments.length>3?arguments[3]:void 0,K=arguments.length>4?arguments[4]:void 0;(0,o.default)(this,R);var $=_.autoconnect,le=$===void 0?!0:$,Ie=_.reconnect,$e=Ie===void 0?!0:Ie,De=_.reconnect_interval,Et=De===void 0?1e3:De,Rt=_.max_reconnects,yt=Rt===void 0?5:Rt,xt=b(_,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return A=I.call(this),A.webSocketFactory=v,A.queue={},A.rpc_id=0,A.address=B,A.autoconnect=le,A.ready=!1,A.reconnect=$e,A.reconnect_timer_id=void 0,A.reconnect_interval=Et,A.max_reconnects=yt,A.rest_options=xt,A.current_reconnects=0,A.generate_request_id=W||function(){return++A.rpc_id},K?A.dataPack=K:A.dataPack=new p.DefaultDataPack,A.autoconnect&&A._connect(A.address,Object.assign({autoconnect:A.autoconnect,reconnect:A.reconnect,reconnect_interval:A.reconnect_interval,max_reconnects:A.max_reconnects},A.rest_options)),A}return(0,i.default)(R,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(A,B,_,W){var K=this;return!W&&(0,n.default)(_)==="object"&&(W=_,_=null),new Promise(function($,le){if(!K.ready)return le(new Error("socket not ready"));var Ie=K.generate_request_id(A,B),$e={jsonrpc:"2.0",method:A,params:B||void 0,id:Ie};K.socket.send(K.dataPack.encode($e),W,function(De){if(De)return le(De);K.queue[Ie]={promise:[$,le]},_&&(K.queue[Ie].timeout=setTimeout(function(){delete K.queue[Ie],le(new Error("reply timeout"))},_))})})}},{key:"login",value:function(){var v=(0,r.default)(t.default.mark(function B(_){var W;return t.default.wrap(function($){for(;;)switch($.prev=$.next){case 0:return $.next=2,this.call("rpc.login",_);case 2:if(W=$.sent,W){$.next=5;break}throw new Error("authentication failed");case 5:return $.abrupt("return",W);case 6:case"end":return $.stop()}},B,this)}));function A(B){return v.apply(this,arguments)}return A}()},{key:"listMethods",value:function(){var v=(0,r.default)(t.default.mark(function B(){return t.default.wrap(function(W){for(;;)switch(W.prev=W.next){case 0:return W.next=2,this.call("__listMethods");case 2:return W.abrupt("return",W.sent);case 3:case"end":return W.stop()}},B,this)}));function A(){return v.apply(this,arguments)}return A}()},{key:"notify",value:function(A,B){var _=this;return new Promise(function(W,K){if(!_.ready)return K(new Error("socket not ready"));var $={jsonrpc:"2.0",method:A,params:B};_.socket.send(_.dataPack.encode($),function(le){if(le)return K(le);W()})})}},{key:"subscribe",value:function(){var v=(0,r.default)(t.default.mark(function B(_){var W;return t.default.wrap(function($){for(;;)switch($.prev=$.next){case 0:return typeof _=="string"&&(_=[_]),$.next=3,this.call("rpc.on",_);case 3:if(W=$.sent,!(typeof _=="string"&&W[_]!=="ok")){$.next=6;break}throw new Error("Failed subscribing to an event '"+_+"' with: "+W[_]);case 6:return $.abrupt("return",W);case 7:case"end":return $.stop()}},B,this)}));function A(B){return v.apply(this,arguments)}return A}()},{key:"unsubscribe",value:function(){var v=(0,r.default)(t.default.mark(function B(_){var W;return t.default.wrap(function($){for(;;)switch($.prev=$.next){case 0:return typeof _=="string"&&(_=[_]),$.next=3,this.call("rpc.off",_);case 3:if(W=$.sent,!(typeof _=="string"&&W[_]!=="ok")){$.next=6;break}throw new Error("Failed unsubscribing from an event with: "+W);case 6:return $.abrupt("return",W);case 7:case"end":return $.stop()}},B,this)}));function A(B){return v.apply(this,arguments)}return A}()},{key:"close",value:function(A,B){this.socket.close(A||1e3,B)}},{key:"_connect",value:function(A,B){var _=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(A,B),this.socket.addEventListener("open",function(){_.ready=!0,_.emit("open"),_.current_reconnects=0}),this.socket.addEventListener("message",function(W){var K=W.data;K instanceof ArrayBuffer&&(K=U.Buffer.from(K).toString());try{K=_.dataPack.decode(K)}catch{return}if(K.notification&&_.listeners(K.notification).length){if(!Object.keys(K.params).length)return _.emit(K.notification);var $=[K.notification];if(K.params.constructor===Object)$.push(K.params);else for(var le=0;le<K.params.length;le++)$.push(K.params[le]);return Promise.resolve().then(function(){_.emit.apply(_,$)})}if(!_.queue[K.id])return K.method?Promise.resolve().then(function(){_.emit(K.method,K==null?void 0:K.params)}):void 0;"error"in K=="result"in K&&_.queue[K.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),_.queue[K.id].timeout&&clearTimeout(_.queue[K.id].timeout),K.error?_.queue[K.id].promise[1](K.error):_.queue[K.id].promise[0](K.result),delete _.queue[K.id]}),this.socket.addEventListener("error",function(W){return _.emit("error",W)}),this.socket.addEventListener("close",function(W){var K=W.code,$=W.reason;_.ready&&setTimeout(function(){return _.emit("close",K,$)},0),_.ready=!1,_.socket=void 0,K!==1e3&&(_.current_reconnects++,_.reconnect&&(_.max_reconnects>_.current_reconnects||_.max_reconnects===0)&&(_.reconnect_timer_id=setTimeout(function(){return _._connect(A,B)},_.reconnect_interval)))})}}]),R}(u.EventEmitter);s.default=w})(Io);const lc=Yt(Io);var Bo={};(function(s){var e=Sn;Object.defineProperty(s,"__esModule",{value:!0}),s.default=p;var t=e(vn()),r=e(In()),n=e(Ao()),o=e(Eo()),i=e(Ro()),a=_n;function c(k){var d=l();return function(){var w=(0,i.default)(k),h;if(d){var I=(0,i.default)(this).constructor;h=Reflect.construct(w,arguments,I)}else h=w.apply(this,arguments);return(0,o.default)(this,h)}}function l(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var u=function(k){(0,n.default)(b,k);var d=c(b);function b(w,h,I){var R;return(0,t.default)(this,b),R=d.call(this),R.socket=new window.WebSocket(w,I),R.socket.onopen=function(){return R.emit("open")},R.socket.onmessage=function(v){return R.emit("message",v.data)},R.socket.onerror=function(v){return R.emit("error",v)},R.socket.onclose=function(v){R.emit("close",v.code,v.reason)},R}return(0,r.default)(b,[{key:"send",value:function(h,I,R){var v=R||I;try{this.socket.send(h),v()}catch(A){v(A)}}},{key:"close",value:function(h,I){this.socket.close(h,I)}},{key:"addEventListener",value:function(h,I,R){this.socket.addEventListener(h,I,R)}}]),b}(a.EventEmitter);function p(k,d){return new u(k,d)}})(Bo);const dc=Yt(Bo),Po=[],To=[],Lo=[],fc=BigInt(0),qt=BigInt(1),hc=BigInt(2),pc=BigInt(7),yc=BigInt(256),gc=BigInt(113);for(let s=0,e=qt,t=1,r=0;s<24;s++){[t,r]=[r,(2*t+3*r)%5],Po.push(2*(5*r+t)),To.push((s+1)*(s+2)/2%64);let n=fc;for(let o=0;o<7;o++)e=(e<<qt^(e>>pc)*gc)%yc,e&hc&&(n^=qt<<(qt<<BigInt(o))-qt);Lo.push(n)}const[bc,mc]=vi(Lo,!0),vs=(s,e,t)=>t>32?Ii(s,e,t):_i(s,e,t),Is=(s,e,t)=>t>32?Ai(s,e,t):Ei(s,e,t);function wc(s,e=24){const t=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let i=0;i<10;i++)t[i]=s[i]^s[i+10]^s[i+20]^s[i+30]^s[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,l=t[c],u=t[c+1],p=vs(l,u,1)^t[a],k=Is(l,u,1)^t[a+1];for(let d=0;d<50;d+=10)s[i+d]^=p,s[i+d+1]^=k}let n=s[2],o=s[3];for(let i=0;i<24;i++){const a=To[i],c=vs(n,o,a),l=Is(n,o,a),u=Po[i];n=s[u],o=s[u+1],s[u]=c,s[u+1]=l}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)t[a]=s[i+a];for(let a=0;a<10;a++)s[i+a]^=~t[(a+2)%10]&t[(a+4)%10]}s[0]^=bc[r],s[1]^=mc[r]}t.fill(0)}class An extends bi{constructor(e,t,r,n=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=n,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Jn(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=mi(this.state)}keccak(){Xn||Zn(this.state32),wc(this.state32,this.rounds),Xn||Zn(this.state32),this.posOut=0,this.pos=0}update(e){Qn(this);const{blockLen:t,state:r}=this;e=wi(e);const n=e.length;for(let o=0;o<n;){const i=Math.min(t-this.pos,n-o);for(let a=0;a<i;a++)r[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:n}=this;e[r]^=t,t&128&&r===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){Qn(this,!1),ki(e),this.finish();const t=this.state,{blockLen:r}=this;for(let n=0,o=e.length;n<o;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,o-n);e.set(t.subarray(this.posOut,this.posOut+i),n),this.posOut+=i,n+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Jn(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Si(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:n,rounds:o,enableXOF:i}=this;return e||(e=new An(t,r,n,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=r,e.outputLen=n,e.enableXOF=i,e.destroyed=this.destroyed,e}}const kc=(s,e,t)=>gi(()=>new An(e,s,t)),_s=kc(1,136,256/8),Sc=Nt.utils.randomPrivateKey,As=()=>{const s=Nt.utils.randomPrivateKey(),e=fr(s),t=new Uint8Array(64);return t.set(s),t.set(e,32),{publicKey:e,secretKey:t}},fr=Nt.getPublicKey;function Es(s){try{return Nt.ExtendedPoint.fromHex(s),!0}catch{return!1}}const En=(s,e)=>Nt.sign(s,e.slice(0,32)),vc=Nt.verify,Y=s=>U.Buffer.isBuffer(s)?s:s instanceof Uint8Array?U.Buffer.from(s.buffer,s.byteOffset,s.byteLength):U.Buffer.from(s);class Rn{constructor(e){Object.assign(this,e)}encode(){return U.Buffer.from(Gs(Vt,this))}static decode(e){return Ys(Vt,this,e)}static decodeUnchecked(e){return Fs(Vt,this,e)}}class Ic extends Rn{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const Vt=new Map;var Co;let Oo;const zo=32,Xe=32;function _c(s){return s._bn!==void 0}let Rs=1;Oo=Symbol.toStringTag;class P extends Rn{constructor(e){if(super({}),this._bn=void 0,_c(e))this._bn=e._bn;else{if(typeof e=="string"){const t=Se.decode(e);if(t.length!=Xe)throw new Error("Invalid public key input");this._bn=new Yn(t)}else this._bn=new Yn(e);if(this._bn.byteLength()>Xe)throw new Error("Invalid public key input")}}static unique(){const e=new P(Rs);return Rs+=1,new P(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Se.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(U.Buffer);if(e.length===Xe)return e;const t=U.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Oo](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const n=U.Buffer.concat([e.toBuffer(),U.Buffer.from(t),r.toBuffer()]),o=rs(n);return new P(o)}static createProgramAddressSync(e,t){let r=U.Buffer.alloc(0);e.forEach(function(o){if(o.length>zo)throw new TypeError("Max seed length exceeded");r=U.Buffer.concat([r,Y(o)])}),r=U.Buffer.concat([r,t.toBuffer(),U.Buffer.from("ProgramDerivedAddress")]);const n=rs(r);if(Es(n))throw new Error("Invalid seeds, address must fall off the curve");return new P(n)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r=255,n;for(;r!=0;){try{const o=e.concat(U.Buffer.from([r]));n=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[n,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new P(e);return Es(t.toBytes())}}Co=P;P.default=new Co("11111111111111111111111111111111");Vt.set(P,{kind:"struct",fields:[["_bn","u256"]]});class Ac{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=Y(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=Y(Sc()),this._publicKey=Y(fr(this._secretKey))}get publicKey(){return new P(this._publicKey)}get secretKey(){return U.Buffer.concat([this._secretKey,this._publicKey],64)}}const Ec=new P("BPFLoader1111111111111111111111111111111111"),pt=1280-40-8,wr=127,jt=64;class xn extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(xn.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Bn extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Bn.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Tt extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Tt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Ht{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const n=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:n(o.programId),accountKeyIndexes:o.keys.map(i=>n(i.pubkey)),data:o.data}))}}const X=(s="publicKey")=>ae(32,s),Rc=(s="signature")=>ae(64,s),wt=(s="string")=>{const e=q([D("length"),D("lengthPadding"),ae(ft(D(),-8),"chars")],s),t=e.decode.bind(e),r=e.encode.bind(e),n=e;return n.decode=(o,i)=>t(o,i).chars.toString(),n.encode=(o,i,a)=>{const c={chars:U.Buffer.from(o,"utf8")};return r(c,i,a)},n.alloc=o=>D().span+D().span+U.Buffer.from(o,"utf8").length,n},xc=(s="authorized")=>q([X("staker"),X("withdrawer")],s),Bc=(s="lockup")=>q([ze("unixTimestamp"),ze("epoch"),X("custodian")],s),Pc=(s="voteInit")=>q([X("nodePubkey"),X("authorizedVoter"),X("authorizedWithdrawer"),Q("commission")],s),Tc=(s="voteAuthorizeWithSeedArgs")=>q([D("voteAuthorizationType"),X("currentAuthorityDerivedKeyOwnerPubkey"),wt("currentAuthorityDerivedKeySeed"),X("newAuthorized")],s);function No(s,e){const t=n=>{if(n.span>=0)return n.span;if(typeof n.alloc=="function")return n.alloc(e[n.property]);if("count"in n&&"elementLayout"in n){const o=e[n.property];if(Array.isArray(o))return o.length*t(n.elementLayout)}else if("fields"in n)return No({layout:n},e[n.property]);return 0};let r=0;return s.layout.fields.forEach(n=>{r+=t(n)}),r}function Pe(s){let e=0,t=0;for(;;){let r=s.shift();if(e|=(r&127)<<t*7,t+=1,!(r&128))break}return e}function Ne(s,e){let t=e;for(;;){let r=t&127;if(t>>=7,t==0){s.push(r);break}else r|=128,s.push(r)}}function ee(s,e){if(!s)throw new Error(e||"Assertion failed")}class kr{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=i=>{const a=i.toBase58();let c=r.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(a,c)),c},o=n(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){n(i.programId).isInvoked=!0;for(const a of i.keys){const c=n(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new kr(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];ee(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),n=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{ee(t.length>0,"Expected at least one writable signer key");const[c]=t[0];ee(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new P(c)),...r.map(([c])=>new P(c)),...n.map(([c])=>new P(c)),...o.map(([c])=>new P(c))];return[i,a]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[n,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&n.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new P(o),c=e.findIndex(l=>l.equals(a));c>=0&&(ee(c<256,"Max lookup table index exceeded"),r.push(c),n.push(a),this.keyMetaMap.delete(o))}return[r,n]}}const Uo="Reached end of buffer unexpectedly";function Ge(s){if(s.length===0)throw new Error(Uo);return s.shift()}function Te(s,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>s.length:t>=s.length)throw new Error(Uo);return s.splice(...e)}class Ve{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new P(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Se.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Ht(this.staticAccountKeys)}static compile(e){const t=kr.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),i=new Ht(n).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:Se.encode(a.data)}));return new Ve({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Ne(t,e);const r=this.instructions.map(p=>{const{accounts:k,programIdIndex:d}=p,b=Array.from(Se.decode(p.data));let w=[];Ne(w,k.length);let h=[];return Ne(h,b.length),{programIdIndex:d,keyIndicesCount:U.Buffer.from(w),keyIndices:k,dataLength:U.Buffer.from(h),data:b}});let n=[];Ne(n,r.length);let o=U.Buffer.alloc(pt);U.Buffer.from(n).copy(o);let i=n.length;r.forEach(p=>{const d=q([Q("programIdIndex"),ae(p.keyIndicesCount.length,"keyIndicesCount"),ve(Q("keyIndex"),p.keyIndices.length,"keyIndices"),ae(p.dataLength.length,"dataLength"),ve(Q("userdatum"),p.data.length,"data")]).encode(p,o,i);i+=d}),o=o.slice(0,i);const a=q([ae(1,"numRequiredSignatures"),ae(1,"numReadonlySignedAccounts"),ae(1,"numReadonlyUnsignedAccounts"),ae(t.length,"keyCount"),ve(X("key"),e,"keys"),X("recentBlockhash")]),c={numRequiredSignatures:U.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:U.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:U.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:U.Buffer.from(t),keys:this.accountKeys.map(p=>Y(p.toBytes())),recentBlockhash:Se.decode(this.recentBlockhash)};let l=U.Buffer.alloc(2048);const u=a.encode(c,l);return o.copy(l,u),l.slice(0,u+o.length)}static from(e){let t=[...e];const r=Ge(t);if(r!==(r&wr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const n=Ge(t),o=Ge(t),i=Pe(t);let a=[];for(let k=0;k<i;k++){const d=Te(t,0,Xe);a.push(new P(U.Buffer.from(d)))}const c=Te(t,0,Xe),l=Pe(t);let u=[];for(let k=0;k<l;k++){const d=Ge(t),b=Pe(t),w=Te(t,0,b),h=Pe(t),I=Te(t,0,h),R=Se.encode(U.Buffer.from(I));u.push({programIdIndex:d,accounts:w,data:R})}const p={header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:o},recentBlockhash:Se.encode(U.Buffer.from(c)),accountKeys:a,instructions:u};return new Ve(p)}}class kt{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Ht(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const n=e-r,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return n<o}else if(e>=this.header.numRequiredSignatures){const n=e-t,i=r-t-this.header.numReadonlyUnsignedAccounts;return n<i}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find(o=>o.key.equals(r.accountKey));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<n.state.addresses.length)t.writable.push(n.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<n.state.addresses.length)t.readonly.push(n.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){const t=kr.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const u of o){const p=t.extractTableLookup(u);if(p!==void 0){const[k,{writable:d,readonly:b}]=p;r.push(k),n.writable.push(...d),n.readonly.push(...b)}}const[i,a]=t.getMessageComponents(),l=new Ht(a,n).compileInstructions(e.instructions);return new kt({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:r})}serialize(){const e=Array();Ne(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();Ne(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),o=Array();Ne(o,this.addressTableLookups.length);const i=q([Q("prefix"),q([Q("numRequiredSignatures"),Q("numReadonlySignedAccounts"),Q("numReadonlyUnsignedAccounts")],"header"),ae(e.length,"staticAccountKeysLength"),ve(X(),this.staticAccountKeys.length,"staticAccountKeys"),X("recentBlockhash"),ae(r.length,"instructionsLength"),ae(t.length,"serializedInstructions"),ae(o.length,"addressTableLookupsLength"),ae(n.length,"serializedAddressTableLookups")]),a=new Uint8Array(pt),c=128,l=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(u=>u.toBytes()),recentBlockhash:Se.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:n},a);return a.slice(0,l)}serializeInstructions(){let e=0;const t=new Uint8Array(pt);for(const r of this.compiledInstructions){const n=Array();Ne(n,r.accountKeyIndexes.length);const o=Array();Ne(o,r.data.length);const i=q([Q("programIdIndex"),ae(n.length,"encodedAccountKeyIndexesLength"),ve(Q(),r.accountKeyIndexes.length,"accountKeyIndexes"),ae(o.length,"encodedDataLength"),ae(r.data.length,"data")]);e+=i.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(pt);for(const r of this.addressTableLookups){const n=Array();Ne(n,r.writableIndexes.length);const o=Array();Ne(o,r.readonlyIndexes.length);const i=q([X("accountKey"),ae(n.length,"encodedWritableIndexesLength"),ve(Q(),r.writableIndexes.length,"writableIndexes"),ae(o.length,"encodedReadonlyIndexesLength"),ve(Q(),r.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=Ge(t),n=r&wr;ee(r!==n,"Expected versioned message but received legacy message");const o=n;ee(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:Ge(t),numReadonlySignedAccounts:Ge(t),numReadonlyUnsignedAccounts:Ge(t)},a=[],c=Pe(t);for(let b=0;b<c;b++)a.push(new P(Te(t,0,Xe)));const l=Se.encode(Te(t,0,Xe)),u=Pe(t),p=[];for(let b=0;b<u;b++){const w=Ge(t),h=Pe(t),I=Te(t,0,h),R=Pe(t),v=new Uint8Array(Te(t,0,R));p.push({programIdIndex:w,accountKeyIndexes:I,data:v})}const k=Pe(t),d=[];for(let b=0;b<k;b++){const w=new P(Te(t,0,Xe)),h=Pe(t),I=Te(t,0,h),R=Pe(t),v=Te(t,0,R);d.push({accountKey:w,writableIndexes:I,readonlyIndexes:v})}return new kt({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:p,addressTableLookups:d})}}const Pn={deserializeMessageVersion(s){const e=s[0],t=e&wr;return t===e?"legacy":t},deserialize:s=>{const e=Pn.deserializeMessageVersion(s);if(e==="legacy")return Ve.from(s);if(e===0)return kt.deserialize(s);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let ot=function(s){return s[s.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",s[s.PROCESSED=1]="PROCESSED",s[s.TIMED_OUT=2]="TIMED_OUT",s[s.NONCE_INVALID=3]="NONCE_INVALID",s}({});const Lc=U.Buffer.alloc(jt).fill(0);class oe{constructor(e){this.keys=void 0,this.programId=void 0,this.data=U.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class re{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new oe(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let w=0;w<t.length;w++)if(t[w].programId===void 0)throw new Error(`Transaction instruction index ${w} has undefined program id`);const n=[],o=[];t.forEach(w=>{w.keys.forEach(I=>{o.push({...I})});const h=w.programId.toString();n.includes(h)||n.push(h)}),n.forEach(w=>{o.push({pubkey:new P(w),isSigner:!1,isWritable:!1})});const i=[];o.forEach(w=>{const h=w.pubkey.toString(),I=i.findIndex(R=>R.pubkey.toString()===h);I>-1?(i[I].isWritable=i[I].isWritable||w.isWritable,i[I].isSigner=i[I].isSigner||w.isSigner):i.push(w)}),i.sort(function(w,h){if(w.isSigner!==h.isSigner)return w.isSigner?-1:1;if(w.isWritable!==h.isWritable)return w.isWritable?-1:1;const I={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return w.pubkey.toBase58().localeCompare(h.pubkey.toBase58(),"en",I)});const a=i.findIndex(w=>w.pubkey.equals(r));if(a>-1){const[w]=i.splice(a,1);w.isSigner=!0,w.isWritable=!0,i.unshift(w)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const w of this.signatures){const h=i.findIndex(I=>I.pubkey.equals(w.publicKey));if(h>-1)i[h].isSigner||(i[h].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${w.publicKey.toString()}`)}let c=0,l=0,u=0;const p=[],k=[];i.forEach(({pubkey:w,isSigner:h,isWritable:I})=>{h?(p.push(w.toString()),c+=1,I||(l+=1)):(k.push(w.toString()),I||(u+=1))});const d=p.concat(k),b=t.map(w=>{const{data:h,programId:I}=w;return{programIdIndex:d.indexOf(I.toString()),accounts:w.keys.map(R=>d.indexOf(R.pubkey.toString())),data:Se.encode(h)}});return b.forEach(w=>{ee(w.programIdIndex>=0),w.accounts.forEach(h=>ee(h>=0))}),new Ve({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:u},accountKeys:d,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((n,o)=>t[o].equals(n.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(r=>{const n=r.toString();return t.has(n)?!1:(t.add(n),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(n=>{const o=En(r,n.secretKey);this._addSignature(n.publicKey,Y(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){ee(t.length===64);const r=this.signatures.findIndex(n=>e.equals(n.publicKey));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=U.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:o}of this.signatures)n===null?t&&(r.missing||(r.missing=[])).push(o):vc(n,e,o.toBytes())||(r.invalid||(r.invalid=[])).push(o);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const o=this._getMessageSignednessErrors(n,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];Ne(r,t.length);const n=r.length+t.length*64+e.length,o=U.Buffer.alloc(n);return ee(t.length<256),U.Buffer.from(r).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(ee(i.length===64,"signature has invalid length"),U.Buffer.from(i).copy(o,r.length+a*64))}),e.copy(o,r.length+t.length*64),ee(o.length<=pt,`Transaction too large: ${o.length} > ${pt}`),o}get keys(){return ee(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return ee(this.instructions.length===1),this.instructions[0].programId}get data(){return ee(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const r=Pe(t);let n=[];for(let o=0;o<r;o++){const i=Te(t,0,jt);n.push(Se.encode(U.Buffer.from(i)))}return re.populate(Ve.from(t),n)}static populate(e,t=[]){const r=new re;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((n,o)=>{const i={signature:n==Se.encode(Lc)?null:Se.decode(n),publicKey:e.accountKeys[o]};r.signatures.push(i)}),e.instructions.forEach(n=>{const o=n.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:r.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});r.instructions.push(new oe({keys:o,programId:e.accountKeys[n.programIdIndex],data:Se.decode(n.data)}))}),r._message=e,r._json=r.toJSON(),r}}class Tn{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:o}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=r,l=i-a;ee(l>0,"Message header is invalid");const u=e.staticAccountKeys.length-i-c;ee(u>=0,"Message header is invalid");const p=e.getAccountKeys(t),k=p.get(0);if(k===void 0)throw new Error("Failed to decompile message because no account keys were found");const d=[];for(const b of n){const w=[];for(const I of b.accountKeyIndexes){const R=p.get(I);if(R===void 0)throw new Error(`Failed to find key for account key index ${I}`);const v=I<i;let A;v?A=I<l:I<p.staticAccountKeys.length?A=I-i<u:A=I-p.staticAccountKeys.length<p.accountKeysFromLookups.writable.length,w.push({pubkey:R,isSigner:I<r.numRequiredSignatures,isWritable:A})}const h=p.get(b.programIdIndex);if(h===void 0)throw new Error(`Failed to find program id for program id index ${b.programIdIndex}`);d.push(new oe({programId:h,data:Y(b.data),keys:w}))}return new Tn({payerKey:k,instructions:d,recentBlockhash:o})}compileToLegacyMessage(){return Ve.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return kt.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class Ln{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)ee(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const r=[];for(let n=0;n<e.header.numRequiredSignatures;n++)r.push(new Uint8Array(jt));this.signatures=r}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Ne(t,this.signatures.length);const r=q([ae(t.length,"encodedSignaturesLength"),ve(Rc(),this.signatures.length,"signatures"),ae(e.length,"serializedMessage")]),n=new Uint8Array(2048),o=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,o)}static deserialize(e){let t=[...e];const r=[],n=Pe(t);for(let i=0;i<n;i++)r.push(new Uint8Array(Te(t,0,jt)));const o=Pn.deserialize(new Uint8Array(t));return new Ln(o,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const o=r.findIndex(i=>i.equals(n.publicKey));ee(o>=0,`Cannot sign with non signer key ${n.publicKey.toBase58()}`),this.signatures[o]=En(t,n.secretKey)}}addSignature(e,t){ee(t.byteLength===64,"Signature must be 64 bytes long");const n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));ee(n>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[n]=t}}const Cc=160,Oc=64,zc=Cc/Oc,Ko=1e3/zc,He=new P("SysvarC1ock11111111111111111111111111111111"),Nc=new P("SysvarEpochSchedu1e111111111111111111111111"),Uc=new P("Sysvar1nstructions1111111111111111111111111"),ur=new P("SysvarRecentB1ockHashes11111111111111111111"),Ot=new P("SysvarRent111111111111111111111111111111111"),Kc=new P("SysvarRewards111111111111111111111111111111"),Wc=new P("SysvarS1otHashes111111111111111111111111111"),Dc=new P("SysvarS1otHistory11111111111111111111111111"),lr=new P("SysvarStakeHistory1111111111111111111111111");async function en(s,e,t,r){const n=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},o=await s.sendTransaction(e,t,n);let i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await s.confirmTransaction({abortSignal:r==null?void 0:r.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},r&&r.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await s.confirmTransaction({abortSignal:r==null?void 0:r.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},r&&r.commitment)).value}else(r==null?void 0:r.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await s.confirmTransaction(o,r&&r.commitment)).value;if(i.err)throw new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function mt(s){return new Promise(e=>setTimeout(e,s))}function Z(s,e){const t=s.layout.span>=0?s.layout.span:No(s,e),r=U.Buffer.alloc(t),n=Object.assign({instruction:s.index},e);return s.layout.encode(n,r),r}function ne(s,e){let t;try{t=s.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.instruction!==s.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${s.index}`);return t}const Wo=we("lamportsPerSignature"),Do=q([D("version"),D("state"),X("authorizedPubkey"),X("nonce"),q([Wo],"feeCalculator")]),tn=Do.span;class Sr{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Do.decode(Y(e),0);return new Sr({authorizedPubkey:new P(t.authorizedPubkey),nonce:new P(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const qc=s=>{const e=s.decode.bind(s),t=s.encode.bind(s);return{decode:e,encode:t}},Mc=s=>e=>{const t=ae(s,e),{encode:r,decode:n}=qc(t),o=t;return o.decode=(i,a)=>{const c=n(i,a);return ba(U.Buffer.from(c))},o.encode=(i,a,c)=>{const l=po(i,s);return r(l,a,c)},o},zt=Mc(8);class Fc{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=D("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(ie))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a SystemInstruction");return n}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=ne(ie.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new P(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=ne(ie.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=ne(ie.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new P(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=ne(ie.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:o}=ne(ie.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new P(t),seed:r,space:n,programId:new P(o)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=ne(ie.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new P(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=ne(ie.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new P(t),seed:r,programId:new P(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:o,programId:i}=ne(ie.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new P(t),seed:r,lamports:n,space:o,programId:new P(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=ne(ie.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new P(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ne(ie.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ne(ie.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=ne(ie.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new P(t)}}static checkProgramId(e){if(!e.equals(be.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ie=Object.freeze({Create:{index:0,layout:q([D("instruction"),ze("lamports"),ze("space"),X("programId")])},Assign:{index:1,layout:q([D("instruction"),X("programId")])},Transfer:{index:2,layout:q([D("instruction"),zt("lamports")])},CreateWithSeed:{index:3,layout:q([D("instruction"),X("base"),wt("seed"),ze("lamports"),ze("space"),X("programId")])},AdvanceNonceAccount:{index:4,layout:q([D("instruction")])},WithdrawNonceAccount:{index:5,layout:q([D("instruction"),ze("lamports")])},InitializeNonceAccount:{index:6,layout:q([D("instruction"),X("authorized")])},AuthorizeNonceAccount:{index:7,layout:q([D("instruction"),X("authorized")])},Allocate:{index:8,layout:q([D("instruction"),ze("space")])},AllocateWithSeed:{index:9,layout:q([D("instruction"),X("base"),wt("seed"),ze("space"),X("programId")])},AssignWithSeed:{index:10,layout:q([D("instruction"),X("base"),wt("seed"),X("programId")])},TransferWithSeed:{index:11,layout:q([D("instruction"),zt("lamports"),wt("seed"),X("programId")])},UpgradeNonceAccount:{index:12,layout:q([D("instruction")])}});class be{constructor(){}static createAccount(e){const t=ie.Create,r=Z(t,{lamports:e.lamports,space:e.space,programId:Y(e.programId.toBuffer())});return new oe({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const n=ie.TransferWithSeed;t=Z(n,{lamports:BigInt(e.lamports),seed:e.seed,programId:Y(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const n=ie.Transfer;t=Z(n,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new oe({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const n=ie.AssignWithSeed;t=Z(n,{base:Y(e.basePubkey.toBuffer()),seed:e.seed,programId:Y(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=ie.Assign;t=Z(n,{programId:Y(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new oe({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=ie.CreateWithSeed,r=Z(t,{base:Y(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:Y(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new oe({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const t=new re;"basePubkey"in e&&"seed"in e?t.add(be.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:tn,programId:this.programId})):t.add(be.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:tn,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=ie.InitializeNonceAccount,r=Z(t,{authorized:Y(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:Ot,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new oe(n)}static nonceAdvance(e){const t=ie.AdvanceNonceAccount,r=Z(t),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new oe(n)}static nonceWithdraw(e){const t=ie.WithdrawNonceAccount,r=Z(t,{lamports:e.lamports});return new oe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:Ot,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=ie.AuthorizeNonceAccount,r=Z(t,{authorized:Y(e.newAuthorizedPubkey.toBuffer())});return new oe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const n=ie.AllocateWithSeed;t=Z(n,{base:Y(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:Y(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=ie.Allocate;t=Z(n,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new oe({keys:r,programId:this.programId,data:t})}}be.programId=new P("11111111111111111111111111111111");const Vc=pt-300;class St{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/St.chunkSize)+1+1)}static async load(e,t,r,n,o){{const p=await e.getMinimumBalanceForRentExemption(o.length),k=await e.getAccountInfo(r.publicKey,"confirmed");let d=null;if(k!==null){if(k.executable)return console.error("Program load failed, account is already executable"),!1;k.data.length!==o.length&&(d=d||new re,d.add(be.allocate({accountPubkey:r.publicKey,space:o.length}))),k.owner.equals(n)||(d=d||new re,d.add(be.assign({accountPubkey:r.publicKey,programId:n}))),k.lamports<p&&(d=d||new re,d.add(be.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:p-k.lamports})))}else d=new re().add(be.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:p>0?p:1,space:o.length,programId:n}));d!==null&&await en(e,d,[t,r],{commitment:"confirmed"})}const i=q([D("instruction"),D("offset"),D("bytesLength"),D("bytesLengthPadding"),ve(Q("byte"),ft(D(),-8),"bytes")]),a=St.chunkSize;let c=0,l=o,u=[];for(;l.length>0;){const p=l.slice(0,a),k=U.Buffer.alloc(a+16);i.encode({instruction:0,offset:c,bytes:p,bytesLength:0,bytesLengthPadding:0},k);const d=new re().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:k});u.push(en(e,d,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await mt(1e3/4),c+=a,l=l.slice(a)}await Promise.all(u);{const p=q([D("instruction")]),k=U.Buffer.alloc(p.span);p.encode({instruction:1},k);const d=new re().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Ot,isSigner:!1,isWritable:!1}],programId:n,data:k}),b="processed",w=await e.sendTransaction(d,[t,r],{preflightCommitment:b}),{context:h,value:I}=await e.confirmTransaction({signature:w,lastValidBlockHeight:d.lastValidBlockHeight,blockhash:d.recentBlockhash},b);if(I.err)throw new Error(`Transaction ${w} failed (${JSON.stringify(I)})`);for(;;){try{if(await e.getSlot({commitment:b})>h.slot)break}catch{}await new Promise(R=>setTimeout(R,Math.round(Ko/2)))}}return!0}}St.chunkSize=Vc;const $c=new P("BPFLoader2111111111111111111111111111111111");class jc{static getMinNumSignatures(e){return St.getMinNumSignatures(e)}static load(e,t,r,n,o){return St.load(e,t,r,o,n)}}function Hc(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var Gc=Object.prototype.toString,Yc=Object.keys||function(s){var e=[];for(var t in s)e.push(t);return e};function Ft(s,e){var t,r,n,o,i,a,c;if(s===!0)return"true";if(s===!1)return"false";switch(typeof s){case"object":if(s===null)return null;if(s.toJSON&&typeof s.toJSON=="function")return Ft(s.toJSON(),e);if(c=Gc.call(s),c==="[object Array]"){for(n="[",r=s.length-1,t=0;t<r;t++)n+=Ft(s[t],!0)+",";return r>-1&&(n+=Ft(s[t],!0)),n+"]"}else if(c==="[object Object]"){for(o=Yc(s).sort(),r=o.length,n="",t=0;t<r;)i=o[t],a=Ft(s[i],!1),a!==void 0&&(n&&(n+=","),n+=JSON.stringify(i)+":"+a),t++;return"{"+n+"}"}else return JSON.stringify(s);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(s);default:return isFinite(s)?s:null}}var Jc=function(s){var e=Ft(s,!1);if(e!==void 0)return""+e},xs=Hc(Jc);const Mt=32;function Hr(s){let e=0;for(;s>1;)s/=2,e++;return e}function Xc(s){return s===0?1:(s--,s|=s>>1,s|=s>>2,s|=s>>4,s|=s>>8,s|=s>>16,s|=s>>32,s+1)}class qo{constructor(e,t,r,n,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Hr(Xc(e+Mt+1))-Hr(Mt)-1,r=this.getSlotsInEpoch(t),n=e-(r-Mt);return[t,n]}else{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),n=this.firstNormalEpoch+r,o=t%this.slotsPerEpoch;return[n,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Mt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Hr(Mt)):this.slotsPerEpoch}}class rn extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}const Zc={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class M extends Error{constructor({code:e,message:t,data:r},n){super(n!=null?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var Qc=globalThis.fetch;class eu extends lc{constructor(e,t,r){const n=o=>{const i=dc(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(n,e,t,r),this.underlyingSocket=void 0}call(...e){var r;const t=(r=this.underlyingSocket)==null?void 0:r.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var r;const t=(r=this.underlyingSocket)==null?void 0:r.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function tu(s,e){let t;try{t=s.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.typeIndex!==s.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${s.index}`);return t}const Bs=56;class nn{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=tu(ru,e),r=e.length-Bs;ee(r>=0,"lookup table is invalid"),ee(r%32===0,"lookup table is invalid");const n=r/32,{addresses:o}=q([ve(X(),n,"addresses")]).decode(e.slice(Bs));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new P(t.authority[0]):void 0,addresses:o.map(i=>new P(i))}}}const ru={index:1,layout:q([D("typeIndex"),zt("deactivationSlot"),we("lastExtendedSlot"),Q("lastExtendedStartIndex"),Q(),ve(X(),ft(Q(),-1),"authority")])},nu=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function su(s){const e=s.match(nu);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${s}\``);const[t,r,n,o]=e,i=s.startsWith("https:")?"wss:":"ws:",a=n==null?null:parseInt(n.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${r}${c}${o}`}const pe=Qt(wn(P),x(),s=>new P(s)),Mo=kn([x(),fe("base64")]),Cn=Qt(wn(U.Buffer),Mo,s=>U.Buffer.from(s[0],"base64")),Fo=30*1e3;function ou(s){if(/^https?:/.test(s)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return s}function ue(s){let e,t;if(typeof s=="string")e=s;else if(s){const{commitment:r,...n}=s;e=r,t=n}return{commitment:e,config:t}}function Vo(s){return Ce([E({jsonrpc:fe("2.0"),id:x(),result:s}),E({jsonrpc:fe("2.0"),id:x(),error:E({code:Zt(),message:x(),data:V(Ea())})})])}const iu=Vo(Zt());function G(s){return Qt(Vo(s),iu,e=>"error"in e?e:{...e,result:T(e.result,s)})}function he(s){return G(E({context:E({slot:f()}),value:s}))}function vr(s){return E({context:E({slot:f()}),value:s})}function Gr(s,e){return s===0?new kt({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new P(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Se.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new Ve(e)}const au=E({foundation:f(),foundationTerm:f(),initial:f(),taper:f(),terminal:f()}),cu=G(N(O(E({epoch:f(),effectiveSlot:f(),amount:f(),postBalance:f(),commission:V(O(f()))})))),uu=N(E({slot:f(),prioritizationFee:f()})),lu=E({total:f(),validator:f(),foundation:f(),epoch:f()}),du=E({epoch:f(),slotIndex:f(),slotsInEpoch:f(),absoluteSlot:f(),blockHeight:V(f()),transactionCount:V(f())}),fu=E({slotsPerEpoch:f(),leaderScheduleSlotOffset:f(),warmup:Qe(),firstNormalEpoch:f(),firstNormalSlot:f()}),hu=bo(x(),N(f())),_t=O(Ce([E({}),x()])),pu=E({err:_t}),yu=fe("receivedSignature"),gu=E({"solana-core":x(),"feature-set":V(f())}),Ps=he(E({err:O(Ce([E({}),x()])),logs:O(N(x())),accounts:V(O(N(O(E({executable:Qe(),owner:x(),lamports:f(),data:N(x()),rentEpoch:V(f())}))))),unitsConsumed:V(f()),returnData:V(O(E({programId:x(),data:kn([x(),fe("base64")])})))})),bu=he(E({byIdentity:bo(x(),N(f())),range:E({firstSlot:f(),lastSlot:f()})}));function mu(s,e,t,r,n,o){const i=t||Qc;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return r&&(c=async(u,p)=>{const k=await new Promise((d,b)=>{try{r(u,p,(w,h)=>d([w,h]))}catch(w){b(w)}});return await i(...k)}),new tc(async(u,p)=>{const k={method:"POST",body:u,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},wl)};try{let d=5,b,w=500;for(;c?b=await c(s,k):b=await i(s,k),!(b.status!==429||n===!0||(d-=1,d===0));)console.error(`Server responded with ${b.status} ${b.statusText}.  Retrying after ${w}ms delay...`),await mt(w),w*=2;const h=await b.text();b.ok?p(null,h):p(new Error(`${b.status} ${b.statusText}: ${h}`))}catch(d){d instanceof Error&&p(d)}},{})}function wu(s){return(e,t)=>new Promise((r,n)=>{s.request(e,t,(o,i)=>{if(o){n(o);return}r(i)})})}function ku(s){return e=>new Promise((t,r)=>{e.length===0&&t([]);const n=e.map(o=>s.request(o.methodName,o.args));s.request(n,(o,i)=>{if(o){r(o);return}t(i)})})}const Su=G(au),vu=G(lu),Iu=G(uu),_u=G(du),Au=G(fu),Eu=G(hu),Ru=G(f()),xu=he(E({total:f(),circulating:f(),nonCirculating:f(),nonCirculatingAccounts:N(pe)})),sn=E({amount:x(),uiAmount:O(f()),decimals:f(),uiAmountString:V(x())}),Bu=he(N(E({address:pe,amount:x(),uiAmount:O(f()),decimals:f(),uiAmountString:V(x())}))),Pu=he(N(E({pubkey:pe,account:E({executable:Qe(),owner:pe,lamports:f(),data:Cn,rentEpoch:f()})}))),on=E({program:x(),parsed:Zt(),space:f()}),Tu=he(N(E({pubkey:pe,account:E({executable:Qe(),owner:pe,lamports:f(),data:on,rentEpoch:f()})}))),Lu=he(N(E({lamports:f(),address:pe}))),Gt=E({executable:Qe(),owner:pe,lamports:f(),data:Cn,rentEpoch:f()}),Cu=E({pubkey:pe,account:Gt}),Ou=Qt(Ce([wn(U.Buffer),on]),Ce([Mo,on]),s=>Array.isArray(s)?T(s,Cn):s),an=E({executable:Qe(),owner:pe,lamports:f(),data:Ou,rentEpoch:f()}),zu=E({pubkey:pe,account:an}),Nu=E({state:Ce([fe("active"),fe("inactive"),fe("activating"),fe("deactivating")]),active:f(),inactive:f()}),Uu=G(N(E({signature:x(),slot:f(),err:_t,memo:O(x()),blockTime:V(O(f()))}))),Ku=G(N(E({signature:x(),slot:f(),err:_t,memo:O(x()),blockTime:V(O(f()))}))),Wu=E({subscription:f(),result:vr(Gt)}),Du=E({pubkey:pe,account:Gt}),qu=E({subscription:f(),result:vr(Du)}),Mu=E({parent:f(),slot:f(),root:f()}),Fu=E({subscription:f(),result:Mu}),Vu=Ce([E({type:Ce([fe("firstShredReceived"),fe("completed"),fe("optimisticConfirmation"),fe("root")]),slot:f(),timestamp:f()}),E({type:fe("createdBank"),parent:f(),slot:f(),timestamp:f()}),E({type:fe("frozen"),slot:f(),timestamp:f(),stats:E({numTransactionEntries:f(),numSuccessfulTransactions:f(),numFailedTransactions:f(),maxTransactionsPerEntry:f()})}),E({type:fe("dead"),slot:f(),timestamp:f(),err:x()})]),$u=E({subscription:f(),result:Vu}),ju=E({subscription:f(),result:vr(Ce([pu,yu]))}),Hu=E({subscription:f(),result:f()}),Gu=E({pubkey:x(),gossip:O(x()),tpu:O(x()),rpc:O(x()),version:O(x())}),Ts=E({votePubkey:x(),nodePubkey:x(),activatedStake:f(),epochVoteAccount:Qe(),epochCredits:N(kn([f(),f(),f()])),commission:f(),lastVote:f(),rootSlot:O(f())}),Yu=G(E({current:N(Ts),delinquent:N(Ts)})),Ju=Ce([fe("processed"),fe("confirmed"),fe("finalized")]),Xu=E({slot:f(),confirmations:O(f()),err:_t,confirmationStatus:V(Ju)}),Zu=he(N(O(Xu))),Qu=G(f()),$o=E({accountKey:pe,writableIndexes:N(f()),readonlyIndexes:N(f())}),On=E({signatures:N(x()),message:E({accountKeys:N(x()),header:E({numRequiredSignatures:f(),numReadonlySignedAccounts:f(),numReadonlyUnsignedAccounts:f()}),instructions:N(E({accounts:N(f()),data:x(),programIdIndex:f()})),recentBlockhash:x(),addressTableLookups:V(N($o))})}),jo=E({pubkey:pe,signer:Qe(),writable:Qe(),source:V(Ce([fe("transaction"),fe("lookupTable")]))}),Ho=E({accountKeys:N(jo),signatures:N(x())}),Go=E({parsed:Zt(),program:x(),programId:pe}),Yo=E({accounts:N(pe),data:x(),programId:pe}),el=Ce([Yo,Go]),tl=Ce([E({parsed:Zt(),program:x(),programId:x()}),E({accounts:N(x()),data:x(),programId:x()})]),Jo=Qt(el,tl,s=>"accounts"in s?T(s,Yo):T(s,Go)),Xo=E({signatures:N(x()),message:E({accountKeys:N(jo),instructions:N(Jo),recentBlockhash:x(),addressTableLookups:V(O(N($o)))})}),hr=E({accountIndex:f(),mint:x(),owner:V(x()),uiTokenAmount:sn}),Zo=E({writable:N(pe),readonly:N(pe)}),Ir=E({err:_t,fee:f(),innerInstructions:V(O(N(E({index:f(),instructions:N(E({accounts:N(f()),data:x(),programIdIndex:f()}))})))),preBalances:N(f()),postBalances:N(f()),logMessages:V(O(N(x()))),preTokenBalances:V(O(N(hr))),postTokenBalances:V(O(N(hr))),loadedAddresses:V(Zo),computeUnitsConsumed:V(f())}),zn=E({err:_t,fee:f(),innerInstructions:V(O(N(E({index:f(),instructions:N(Jo)})))),preBalances:N(f()),postBalances:N(f()),logMessages:V(O(N(x()))),preTokenBalances:V(O(N(hr))),postTokenBalances:V(O(N(hr))),loadedAddresses:V(Zo),computeUnitsConsumed:V(f())}),Wt=Ce([fe(0),fe("legacy")]),At=E({pubkey:x(),lamports:f(),postBalance:O(f()),rewardType:O(x()),commission:V(O(f()))}),rl=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),transactions:N(E({transaction:On,meta:O(Ir),version:V(Wt)})),rewards:V(N(At)),blockTime:O(f()),blockHeight:O(f())}))),nl=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),rewards:V(N(At)),blockTime:O(f()),blockHeight:O(f())}))),sl=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),transactions:N(E({transaction:Ho,meta:O(Ir),version:V(Wt)})),rewards:V(N(At)),blockTime:O(f()),blockHeight:O(f())}))),ol=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),transactions:N(E({transaction:Xo,meta:O(zn),version:V(Wt)})),rewards:V(N(At)),blockTime:O(f()),blockHeight:O(f())}))),il=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),transactions:N(E({transaction:Ho,meta:O(zn),version:V(Wt)})),rewards:V(N(At)),blockTime:O(f()),blockHeight:O(f())}))),al=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),rewards:V(N(At)),blockTime:O(f()),blockHeight:O(f())}))),cl=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),transactions:N(E({transaction:On,meta:O(Ir)})),rewards:V(N(At)),blockTime:O(f())}))),Ls=G(O(E({blockhash:x(),previousBlockhash:x(),parentSlot:f(),signatures:N(x()),blockTime:O(f())}))),Yr=G(O(E({slot:f(),meta:O(Ir),blockTime:V(O(f())),transaction:On,version:V(Wt)}))),cr=G(O(E({slot:f(),transaction:Xo,meta:O(zn),blockTime:V(O(f())),version:V(Wt)}))),ul=he(E({blockhash:x(),feeCalculator:E({lamportsPerSignature:f()})})),ll=he(E({blockhash:x(),lastValidBlockHeight:f()})),dl=he(Qe()),fl=E({slot:f(),numTransactions:f(),numSlots:f(),samplePeriodSecs:f()}),hl=G(N(fl)),pl=he(O(E({feeCalculator:E({lamportsPerSignature:f()})}))),yl=G(x()),gl=G(x()),bl=E({err:_t,logs:N(x()),signature:x()}),ml=E({result:vr(bl),subscription:f()}),wl={"solana-client":"js/0.0.0-development"};class kl{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const l={};return async u=>{const{commitment:p,config:k}=ue(u),d=this._buildArgs([],p,void 0,k),b=xs(d);return l[b]=l[b]??(async()=>{try{const w=await this._rpcRequest("getBlockHeight",d),h=T(w,G(f()));if("error"in h)throw new M(h.error,"failed to get block height information");return h.result}finally{delete l[b]}})(),await l[b]}})();let r,n,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,n=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=ou(e),this._rpcWsEndpoint=r||su(e),this._rpcClient=mu(e,n,o,i,a,c),this._rpcRequest=wu(this._rpcClient),this._rpcBatchRequest=ku(this._rpcClient),this._rpcWebSocket=new eu(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgs([e.toBase58()],r,void 0,n),i=await this._rpcRequest("getBalance",o),a=T(i,he(f()));if("error"in a)throw new M(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=T(t,G(O(f())));if("error"in r)throw new M(r.error,`failed to get block time for slot ${e}`);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=T(e,G(f()));if("error"in t)throw new M(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=T(e,Ru);if("error"in t)throw new M(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),n=T(r,xu);if("error"in n)throw new M(n.error,"failed to get supply");return n.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenSupply",r),o=T(n,he(sn));if("error"in o)throw new M(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenAccountBalance",r),o=T(n,he(sn));if("error"in o)throw new M(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,r){const{commitment:n,config:o}=ue(r);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,n,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),l=T(c,Pu);if("error"in l)throw new M(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const o=this._buildArgs(n,r,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=T(i,Tu);if("error"in a)throw new M(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=await this._rpcRequest("getLargestAccounts",r),o=T(n,Lu);if("error"in o)throw new M(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenLargestAccounts",r),o=T(n,Bu);if("error"in o)throw new M(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgs([e.toBase58()],r,"base64",n),i=await this._rpcRequest("getAccountInfo",o),a=T(i,he(O(Gt)));if("error"in a)throw new M(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",n),i=await this._rpcRequest("getAccountInfo",o),a=T(i,he(O(an)));if("error"in a)throw new M(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:n}=ue(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],r,"jsonParsed",n),a=await this._rpcRequest("getMultipleAccounts",i),c=T(a,he(N(O(an))));if("error"in c)throw new M(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:n}=ue(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],r,"base64",n),a=await this._rpcRequest("getMultipleAccounts",i),c=T(a,he(N(O(Gt))));if("error"in c)throw new M(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const{commitment:n,config:o}=ue(t),i=this._buildArgs([e.toBase58()],n,void 0,{...o,epoch:r??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=T(a,G(Nu));if("error"in c)throw new M(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:r,config:n}=ue(t),{encoding:o,...i}=n||{},a=this._buildArgs([e.toBase58()],r,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),l=N(Cu),u=i.withContext===!0?T(c,he(l)):T(c,G(l));if("error"in u)throw new M(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",n),i=await this._rpcRequest("getProgramAccounts",o),a=T(i,G(N(zu)));if("error"in a)throw new M(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var o;let r;if(typeof e=="string")r=e;else{const i=e;if((o=i.abortSignal)!=null&&o.aborted)return Promise.reject(i.abortSignal.reason);r=i.signature}let n;try{n=Se.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return ee(n.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{e!=null&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,o=!1;const i=new Promise((c,l)=>{try{r=this.onSignature(t,(p,k)=>{r=void 0;const d={context:k,value:p};c({__type:ot.PROCESSED,response:d})},e);const u=new Promise(p=>{r==null?p():n=this._onSubscriptionStateChange(r,k=>{k==="subscribed"&&p()})});(async()=>{if(await u,o)return;const p=await this.getSignatureStatus(t);if(o||p==null)return;const{context:k,value:d}=p;if(d!=null)if(d!=null&&d.err)l(d.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(d.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(d.confirmationStatus==="processed"||d.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:ot.PROCESSED,response:{context:k,value:d}})}})()}catch(u){l(u)}});return{abortConfirmation:()=>{n&&(n(),n=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let o=!1;const i=new Promise(p=>{const k=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let d=await k();if(!o){for(;d<=r;)if(await mt(1e3),o||(d=await k(),o))return;p({__type:ot.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),l=this.getCancellationPromise(t);let u;try{const p=await Promise.race([l,c,i]);if(p.__type===ot.PROCESSED)u=p.response;else throw new xn(n)}finally{o=!0,a()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(d=>{let b=o,w=null;const h=async()=>{try{const{context:I,value:R}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return w=I.slot,R==null?void 0:R.nonce}catch{return b}};(async()=>{if(b=await h(),!a)for(;;){if(o!==b){d({__type:ot.NONCE_INVALID,slotInWhichNonceDidAdvance:w});return}if(await mt(2e3),a||(b=await h(),a))return}})()}),{abortConfirmation:l,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),p=this.getCancellationPromise(t);let k;try{const d=await Promise.race([p,u,c]);if(d.__type===ot.PROCESSED)k=d.response;else{let b;for(;;){const w=await this.getSignatureStatus(i);if(w==null)break;if(w.context.slot<(d.slotInWhichNonceDidAdvance??r)){await mt(400);continue}b=w;break}if(b!=null&&b.value){const w=e||"finalized",{confirmationStatus:h}=b.value;switch(w){case"processed":case"recent":if(h!=="processed"&&h!=="confirmed"&&h!=="finalized")throw new Tt(i);break;case"confirmed":case"single":case"singleGossip":if(h!=="confirmed"&&h!=="finalized")throw new Tt(i);break;case"finalized":case"max":case"root":if(h!=="finalized")throw new Tt(i);break;default:(I=>{})(w)}k={context:b.context,value:{err:b.value.err}}}else throw new Tt(i)}}finally{a=!0,l()}return k}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const n=new Promise(c=>{let l=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{l=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>c({__type:ot.TIMED_OUT,timeoutMs:l}),l)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,n]);if(c.__type===ot.PROCESSED)a=c.response;else throw new Bn(t,c.timeoutMs/1e3)}finally{clearTimeout(r),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=T(e,G(N(Gu)));if("error"in t)throw new M(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),n=T(r,Yu);if("error"in n)throw new M(n.error,"failed to get vote accounts");return n.result}async getSlot(e){const{commitment:t,config:r}=ue(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlot",n),i=T(o,G(f()));if("error"in i)throw new M(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:r}=ue(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlotLeader",n),i=T(o,G(x()));if("error"in i)throw new M(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const r=[e,t],n=await this._rpcRequest("getSlotLeaders",r),o=T(n,G(N(pe)));if("error"in o)throw new M(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);ee(n.length===1);const o=n[0];return{context:r,value:o}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=await this._rpcRequest("getSignatureStatuses",r),o=T(n,Zu);if("error"in o)throw new M(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:r}=ue(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getTransactionCount",n),i=T(o,G(f()));if("error"in i)throw new M(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),n=T(r,Su);if("error"in n)throw new M(n.error,"failed to get inflation");return n.result}async getInflationReward(e,t,r){const{commitment:n,config:o}=ue(r),i=this._buildArgs([e.map(l=>l.toBase58())],n,void 0,{...o,epoch:t??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=T(a,cu);if("error"in c)throw new M(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=T(e,vu);if("error"in t)throw new M(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=ue(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getEpochInfo",n),i=T(o,_u);if("error"in i)throw new M(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=T(e,Au);if("error"in t)throw new M(t.error,"failed to get epoch schedule");const r=t.result;return new qo(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=T(e,Eu);if("error"in t)throw new M(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),o=T(n,Qu);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),n=T(r,ul);if("error"in n)throw new M(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=T(t,hl);if("error"in r)throw new M(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),o=T(n,pl);if("error"in o)throw new M(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const r=Y(e.serialize()).toString("base64"),n=this._buildArgs([r],t),o=await this._rpcRequest("getFeeForMessage",n),i=T(o,he(O(f())));if("error"in i)throw new M(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),r=t!=null&&t.length?[t]:[],n=await this._rpcRequest("getRecentPrioritizationFees",r),o=T(n,Iu);if("error"in o)throw new M(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=ue(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getLatestBlockhash",n),i=T(o,ll);if("error"in i)throw new M(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgs([e],r,void 0,n),i=await this._rpcRequest("isBlockhashValid",o),a=T(i,dl);if("error"in a)throw new M(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=T(e,G(gu));if("error"in t)throw new M(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=T(e,G(x()));if("error"in t)throw new M(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,n),i=await this._rpcRequest("getBlock",o);try{switch(n==null?void 0:n.transactionDetails){case"accounts":{const a=T(i,sl);if("error"in a)throw a.error;return a.result}case"none":{const a=T(i,nl);if("error"in a)throw a.error;return a.result}default:{const a=T(i,rl);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:l,meta:u,version:p})=>({meta:u,transaction:{...l,message:Gr(p,l.message)},version:p}))}:null}}}catch(a){throw new M(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),i=await this._rpcRequest("getBlock",o);try{switch(n==null?void 0:n.transactionDetails){case"accounts":{const a=T(i,il);if("error"in a)throw a.error;return a.result}case"none":{const a=T(i,al);if("error"in a)throw a.error;return a.result}default:{const a=T(i,ol);if("error"in a)throw a.error;return a.result}}}catch(a){throw new M(a,"failed to get block")}}async getBlockProduction(e){let t,r;if(typeof e=="string")r=e;else if(e){const{commitment:a,...c}=e;r=a,t=c}const n=this._buildArgs([],r,"base64",t),o=await this._rpcRequest("getBlockProduction",n),i=T(o,bu);if("error"in i)throw new M(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,n),i=await this._rpcRequest("getTransaction",o),a=T(i,Yr);if("error"in a)throw new M(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Gr(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:r,config:n}=ue(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),i=await this._rpcRequest("getTransaction",o),a=T(i,cr);if("error"in a)throw new M(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:r,config:n}=ue(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],r,"jsonParsed",n)}));return(await this._rpcBatchRequest(o)).map(c=>{const l=T(c,cr);if("error"in l)throw new M(l.error,"failed to get transactions");return l.result})}async getTransactions(e,t){const{commitment:r,config:n}=ue(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],r,void 0,n)}));return(await this._rpcBatchRequest(o)).map(c=>{const l=T(c,Yr);if("error"in l)throw new M(l.error,"failed to get transactions");const u=l.result;return u&&{...u,transaction:{...u.transaction,message:Gr(u.version,u.transaction.message)}}})}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedBlock",r),o=T(n,cl);if("error"in o)throw new M(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:l})=>{const u=new Ve(c.message);return{meta:l,transaction:{...c,message:u}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:re.populate(c.message,c.signatures)}))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],r),o=await this._rpcRequest("getBlocks",n),i=T(o,G(N(f())));if("error"in i)throw new M(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),o=T(n,Ls);if("error"in o)throw new M(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),o=T(n,Ls);if("error"in o)throw new M(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedTransaction",r),o=T(n,Yr);if("error"in o)throw new M(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new Ve(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:re.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),o=T(n,cr);if("error"in o)throw new M(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const r=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(i=>{const a=T(i,cr);if("error"in a)throw new M(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,r){let n={},o=await this.getFirstAvailableBlock();for(;!("until"in n)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(n.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in n)&&(r++,!(r>i));)try{const c=await this.getConfirmedBlockSignatures(r);c.signatures.length>0&&(n.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,n)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),i=T(o,Uu);if("error"in i)throw new M(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",n),i=T(o,Ku);if("error"in i)throw new M(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let o=null;return n!==null&&(o=new nn({key:e,state:nn.deserialize(n.data)})),{context:r,value:o}}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let o=null;return n!==null&&(o=Sr.fromAccountData(n.data)),{context:r,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),n=T(r,yl);if("error"in n)throw new M(n.error,`airdrop to ${e.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await mt(100);const r=Date.now()-this._blockhashInfo.lastFetch>=Fo;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){const o=await this.getLatestBlockhash("finalized");if(r!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await mt(Ko/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=ue(e),n=this._buildArgs([],t,"base64",r),o=await this._rpcRequest("getStakeMinimumDelegation",n),i=T(o,he(f()));if("error"in i)throw new M(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,r){if("message"in e){const w=e.serialize(),h=U.Buffer.from(w).toString("base64");if(Array.isArray(t)||r!==void 0)throw new Error("Invalid arguments");const I=t||{};I.encoding="base64","commitment"in I||(I.commitment=this.commitment);const R=[h,I],v=await this._rpcRequest("simulateTransaction",R),A=T(v,Ps);if("error"in A)throw new Error("failed to simulate transaction: "+A.error.message);return A.result}let n;if(e instanceof re){let b=e;n=new re,n.feePayer=b.feePayer,n.instructions=e.instructions,n.nonceInfo=b.nonceInfo,n.signatures=b.signatures}else n=re.populate(e),n._message=n._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(n.nonceInfo&&o)n.sign(...o);else{let b=this._disableBlockhashCaching;for(;;){const w=await this._blockhashWithExpiryBlockHeight(b);if(n.lastValidBlockHeight=w.lastValidBlockHeight,n.recentBlockhash=w.blockhash,!o)break;if(n.sign(...o),!n.signature)throw new Error("!signature");const h=n.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(h)&&!this._blockhashInfo.transactionSignatures.includes(h)){this._blockhashInfo.simulatedSignatures.push(h);break}else b=!0}}const i=n._compile(),a=i.serialize(),l=n._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};if(r){const b=(Array.isArray(r)?r:i.nonProgramIds()).map(w=>w.toBase58());u.accounts={encoding:"base64",addresses:b}}o&&(u.sigVerify=!0);const p=[l,u],k=await this._rpcRequest("simulateTransaction",p),d=T(k,Ps);if("error"in d){let b;if("data"in d.error&&(b=d.error.data.logs,b&&Array.isArray(b))){const w=`
    `,h=w+b.join(w);console.error(d.error.message,h)}throw new rn("failed to simulate transaction: "+d.error.message,b)}return d.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(e.nonceInfo)e.sign(...n);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...n),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,r)}async sendRawTransaction(e,t){const r=Y(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,o=n===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(r.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),o&&(r.preflightCommitment=o);const i=[e,r],a=await this._rpcRequest("sendTransaction",i),c=T(a,gl);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new rn("failed to send transaction: "+c.error.message,l)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,r])=>{this._setSubscription(t,{...r,state:"pending"})})}_setSubscription(e,t){var n;const r=(n=this._subscriptionsByHash[e])==null?void 0:n.state;if(this._subscriptionsByHash[e]=t,r!==t.state){const o=this._subscriptionStateChangeCallbacksByHash[e];o&&o.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const r=this._subscriptionHashByClientSubscriptionId[e];if(r==null)return()=>{};const n=(o=this._subscriptionStateChangeCallbacksByHash)[r]||(o[r]=new Set);return n.add(t),()=>{n.delete(t),n.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const n=this._subscriptionsByHash[r];if(n!==void 0)switch(n.state){case"pending":case"unsubscribed":if(n.callbacks.size===0){delete this._subscriptionsByHash[r],n.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=n;try{this._setSubscription(r,{...n,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(r,{...n,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=n.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(r,{...n,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":n.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=n;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(r,{...n,state:"unsubscribing"}),this._setSubscription(r,{...n,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(r,{...n,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...n,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];r!==void 0&&r.forEach(n=>{try{n(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=T(e,Wu);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=xs([e.method,t],!0),o=this._subscriptionsByHash[n];return o===void 0?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const i=this._subscriptionsByHash[n];ee(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},n)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=T(e,qu);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const o=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",n?{filters:n}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=T(e,ml);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=T(e,Fu);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=T(e,$u);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,n){const o=t||this._commitment;if(o||r||n){let i={};r&&(i.encoding=r),o&&(i.commitment=o),n&&(i=Object.assign(i,n)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=T(e,ju);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return o}onSignatureWithOptions(e,t,r){const{commitment:n,...o}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},i=this._buildArgs([e],n,void 0,o),a=this._makeSubscription({callback:(c,l)=>{t(c,l);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=T(e,Hu);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Lt{constructor(e){this._keypair=void 0,this._keypair=e??As()}static generate(){return new Lt(As())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const n=e.slice(0,32),o=fr(n);for(let i=0;i<32;i++)if(r[i]!==o[i])throw new Error("provided secretKey is invalid")}return new Lt({publicKey:r,secretKey:e})}static fromSeed(e){const t=fr(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Lt({publicKey:t,secretKey:r})}get publicKey(){return new P(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const it=Object.freeze({CreateLookupTable:{index:0,layout:q([D("instruction"),zt("recentSlot"),Q("bumpSeed")])},FreezeLookupTable:{index:1,layout:q([D("instruction")])},ExtendLookupTable:{index:2,layout:q([D("instruction"),zt(),ve(X(),ft(D(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:q([D("instruction")])},CloseLookupTable:{index:4,layout:q([D("instruction")])}});class Sl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=D("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(it))if(i.index==r){n=o;break}if(!n)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return n}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=ne(it.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=ne(it.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(r=>new P(r))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Nn.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class Nn{constructor(){}static createLookupTable(e){const[t,r]=P.findProgramAddressSync([e.authority.toBuffer(),po(BigInt(e.recentSlot),8)],this.programId),n=it.CreateLookupTable,o=Z(n,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:be.programId,isSigner:!1,isWritable:!1}];return[new oe({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){const t=it.FreezeLookupTable,r=Z(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new oe({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const t=it.ExtendLookupTable,r=Z(t,{addresses:e.addresses.map(o=>o.toBytes())}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:be.programId,isSigner:!1,isWritable:!1}),new oe({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const t=it.DeactivateLookupTable,r=Z(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new oe({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const t=it.CloseLookupTable,r=Z(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new oe({programId:this.programId,keys:n,data:r})}}Nn.programId=new P("AddressLookupTab1e1111111111111111111111111");class vl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=Q("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(Ye))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return n}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=ne(Ye.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=ne(Ye.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=ne(Ye.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=ne(Ye.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(Un.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Ye=Object.freeze({RequestUnits:{index:0,layout:q([Q("instruction"),D("units"),D("additionalFee")])},RequestHeapFrame:{index:1,layout:q([Q("instruction"),D("bytes")])},SetComputeUnitLimit:{index:2,layout:q([Q("instruction"),D("units")])},SetComputeUnitPrice:{index:3,layout:q([Q("instruction"),zt("microLamports")])}});class Un{constructor(){}static requestUnits(e){const t=Ye.RequestUnits,r=Z(t,e);return new oe({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const t=Ye.RequestHeapFrame,r=Z(t,e);return new oe({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const t=Ye.SetComputeUnitLimit,r=Z(t,e);return new oe({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const t=Ye.SetComputeUnitPrice,r=Z(t,{microLamports:BigInt(e.microLamports)});return new oe({keys:[],programId:this.programId,data:r})}}Un.programId=new P("ComputeBudget111111111111111111111111111111");const Cs=64,Os=32,zs=64,Ns=q([Q("numSignatures"),Q("padding"),Ke("signatureOffset"),Ke("signatureInstructionIndex"),Ke("publicKeyOffset"),Ke("publicKeyInstructionIndex"),Ke("messageDataOffset"),Ke("messageDataSize"),Ke("messageInstructionIndex")]);class _r{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,instructionIndex:o}=e;ee(t.length===Os,`Public Key must be ${Os} bytes but received ${t.length} bytes`),ee(n.length===zs,`Signature must be ${zs} bytes but received ${n.length} bytes`);const i=Ns.span,a=i+t.length,c=a+n.length,l=1,u=U.Buffer.alloc(c+r.length),p=o??65535;return Ns.encode({numSignatures:l,padding:0,signatureOffset:a,signatureInstructionIndex:p,publicKeyOffset:i,publicKeyInstructionIndex:p,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:p},u),u.fill(t,i),u.fill(n,a),u.fill(r,c),new oe({keys:[],programId:_r.programId,data:u})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;ee(t.length===Cs,`Private key must be ${Cs} bytes but received ${t.length} bytes`);try{const o=Lt.fromSecretKey(t),i=o.publicKey.toBytes(),a=En(r,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:a,instructionIndex:n})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}_r.programId=new P("Ed25519SigVerify111111111111111111111111111");const Il=(s,e)=>{const t=cn.sign(s,e);return[t.toCompactRawBytes(),t.recovery]};cn.utils.isValidPrivateKey;const _l=cn.getPublicKey,Us=32,Jr=20,Ks=64,Al=11,Xr=q([Q("numSignatures"),Ke("signatureOffset"),Q("signatureInstructionIndex"),Ke("ethAddressOffset"),Q("ethAddressInstructionIndex"),Ke("messageDataOffset"),Ke("messageDataSize"),Q("messageInstructionIndex"),ae(20,"ethAddress"),ae(64,"signature"),Q("recoveryId")]);class Ct{constructor(){}static publicKeyToEthAddress(e){ee(e.length===Ks,`Public key must be ${Ks} bytes but received ${e.length} bytes`);try{return U.Buffer.from(_s(Y(e))).slice(-Jr)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:o,instructionIndex:i}=e;return Ct.createInstructionWithEthAddress({ethAddress:Ct.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:n,recoveryId:o,instructionIndex:i=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=U.Buffer.from(t.substr(2),"hex"):a=U.Buffer.from(t,"hex"):a=t,ee(a.length===Jr,`Address must be ${Jr} bytes but received ${a.length} bytes`);const c=1+Al,l=c,u=c+a.length,p=u+n.length+1,k=1,d=U.Buffer.alloc(Xr.span+r.length);return Xr.encode({numSignatures:k,signatureOffset:u,signatureInstructionIndex:i,ethAddressOffset:l,ethAddressInstructionIndex:i,messageDataOffset:p,messageDataSize:r.length,messageInstructionIndex:i,signature:Y(n),ethAddress:Y(a),recoveryId:o},d),d.fill(Y(r),Xr.span),new oe({keys:[],programId:Ct.programId,data:d})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;ee(t.length===Us,`Private key must be ${Us} bytes but received ${t.length} bytes`);try{const o=Y(t),i=_l(o,!1).slice(1),a=U.Buffer.from(_s(Y(r))),[c,l]=Il(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:c,recoveryId:l,instructionIndex:n})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}Ct.programId=new P("KeccakSecp256k11111111111111111111111111111");var Qo;const ei=new P("StakeConfig11111111111111111111111111111111");class ti{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class tr{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}Qo=tr;tr.default=new Qo(0,0,P.default);class El{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=D("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(ge))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a StakeInstruction");return n}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:r}=ne(ge.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new ti(new P(t.staker),new P(t.withdrawer)),lockup:new tr(r.unixTimestamp,r.epoch,new P(r.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),ne(ge.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:r}=ne(ge.Authorize,e.data),n={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new P(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(n.custodianPubkey=e.keys[3].pubkey),n}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:r,authoritySeed:n,authorityOwner:o}=ne(ge.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:n,authorityOwner:new P(o),newAuthorizedPubkey:new P(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ne(ge.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ne(ge.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ne(ge.Withdraw,e.data),r={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(r.custodianPubkey=e.keys[5].pubkey),r}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ne(ge.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(Ar.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ge=Object.freeze({Initialize:{index:0,layout:q([D("instruction"),xc(),Bc()])},Authorize:{index:1,layout:q([D("instruction"),X("newAuthorized"),D("stakeAuthorizationType")])},Delegate:{index:2,layout:q([D("instruction")])},Split:{index:3,layout:q([D("instruction"),ze("lamports")])},Withdraw:{index:4,layout:q([D("instruction"),ze("lamports")])},Deactivate:{index:5,layout:q([D("instruction")])},Merge:{index:7,layout:q([D("instruction")])},AuthorizeWithSeed:{index:8,layout:q([D("instruction"),X("newAuthorized"),D("stakeAuthorizationType"),wt("authoritySeed"),X("authorityOwner")])}}),Rl=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Ar{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,o=n||tr.default,i=ge.Initialize,a=Z(i,{authorized:{staker:Y(r.staker.toBuffer()),withdrawer:Y(r.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:Y(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ot,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new oe(c)}static createAccountWithSeed(e){const t=new re;t.add(be.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static createAccount(e){const t=new re;t.add(be.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,o=ge.Delegate,i=Z(o);return new re().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:lr,isSigner:!1,isWritable:!1},{pubkey:ei,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:o,custodianPubkey:i}=e,a=ge.Authorize,c=Z(a,{newAuthorized:Y(n.toBuffer()),stakeAuthorizationType:o.index}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new re().add({keys:l,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,l=ge.AuthorizeWithSeed,u=Z(l,{newAuthorized:Y(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:n,authorityOwner:Y(o.toBuffer())}),p=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:He,isSigner:!1,isWritable:!1}];return c&&p.push({pubkey:c,isSigner:!0,isWritable:!1}),new re().add({keys:p,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:o}=e,i=ge.Split,a=Z(i,{lamports:o});return new oe({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){const r=new re;return r.add(be.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,l=new re;return l.add(be.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&l.add(be.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),l.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:o,lamports:c}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,o=ge.Merge,i=Z(o);return new re().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:lr,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:o,custodianPubkey:i}=e,a=ge.Withdraw,c=Z(a,{lamports:o}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:lr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new re().add({keys:l,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=ge.Deactivate,o=Z(n);return new re().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}}Ar.programId=new P("Stake11111111111111111111111111111111111111");Ar.space=200;class ri{constructor(e,t,r,n){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=r,this.commission=n}}class xl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=D("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(Je))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a VoteInstruction");return n}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=ne(Je.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new ri(new P(t.nodePubkey),new P(t.authorizedVoter),new P(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:r}=ne(Je.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new P(t),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:r,newAuthorized:n,voteAuthorizationType:o}}=ne(Je.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new P(t),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new P(n),voteAuthorizationType:{index:o},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ne(Je.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Dt.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Je=Object.freeze({InitializeAccount:{index:0,layout:q([D("instruction"),Pc()])},Authorize:{index:1,layout:q([D("instruction"),X("newAuthorized"),D("voteAuthorizationType")])},Withdraw:{index:3,layout:q([D("instruction"),ze("lamports")])},UpdateValidatorIdentity:{index:4,layout:q([D("instruction")])},AuthorizeWithSeed:{index:10,layout:q([D("instruction"),Tc()])}}),Bl=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Dt{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,o=Je.InitializeAccount,i=Z(o,{voteInit:{nodePubkey:Y(n.nodePubkey.toBuffer()),authorizedVoter:Y(n.authorizedVoter.toBuffer()),authorizedWithdrawer:Y(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ot,isSigner:!1,isWritable:!1},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new oe(a)}static createAccount(e){const t=new re;return t.add(be.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:o}=e,i=Je.Authorize,a=Z(i,{newAuthorized:Y(n.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new re().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=Je.AuthorizeWithSeed,l=Z(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:Y(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:Y(o.toBuffer()),voteAuthorizationType:i.index}}),u=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new re().add({keys:u,programId:this.programId,data:l})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:o}=e,i=Je.Withdraw,a=Z(i,{lamports:n}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return new re().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return Dt.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,o=Je.UpdateValidatorIdentity,i=Z(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new re().add({keys:a,programId:this.programId,data:i})}}Dt.programId=new P("Vote111111111111111111111111111111111111111");Dt.space=3762;const ni=new P("Va1idator1nfo111111111111111111111111111111"),Pl=E({name:x(),website:V(x()),details:V(x()),keybaseUsername:V(x())});class Kn{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(Pe(t)!==2)return null;const n=[];for(let o=0;o<2;o++){const i=new P(Te(t,0,Xe)),a=Ge(t)===1;n.push({publicKey:i,isSigner:a})}if(n[0].publicKey.equals(ni)&&n[1].isSigner){const o=wt().decode(U.Buffer.from(t)),i=JSON.parse(o);return yo(i,Pl),new Kn(n[1].publicKey,i)}return null}}const Tl=new P("Vote111111111111111111111111111111111111111"),Ll=q([X("nodePubkey"),X("authorizedWithdrawer"),Q("commission"),we(),ve(q([we("slot"),D("confirmationCount")]),ft(D(),-8),"votes"),Q("rootSlotValid"),we("rootSlot"),we(),ve(q([we("epoch"),X("authorizedVoter")]),ft(D(),-8),"authorizedVoters"),q([ve(q([X("authorizedPubkey"),we("epochOfLastAuthorizedSwitch"),we("targetEpoch")]),32,"buf"),we("idx"),Q("isEmpty")],"priorVoters"),we(),ve(q([we("epoch"),we("credits"),we("prevCredits")]),ft(D(),-8),"epochCredits"),q([we("slot"),we("timestamp")],"lastTimestamp")]);class Wn{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const r=Ll.decode(Y(e),4);let n=r.rootSlot;return r.rootSlotValid||(n=null),new Wn({nodePubkey:new P(r.nodePubkey),authorizedWithdrawer:new P(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:n,authorizedVoters:r.authorizedVoters.map(Cl),priorVoters:Ol(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Cl({authorizedVoter:s,epoch:e}){return{epoch:e,authorizedVoter:new P(s)}}function Ws({authorizedPubkey:s,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new P(s),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function Ol({buf:s,idx:e,isEmpty:t}){return t?[]:[...s.slice(e+1).map(Ws),...s.slice(0,e).map(Ws)]}const Ds={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function zl(s,e){const t=e===!1?"http":"https";if(!s)return Ds[t].devnet;const r=Ds[t][s];if(!r)throw new Error(`Unknown ${t} cluster: ${s}`);return r}async function Nl(s,e,t,r){let n,o;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(n=t,o=r):o=t;const i=o&&{skipPreflight:o.skipPreflight,preflightCommitment:o.preflightCommitment||o.commitment,minContextSlot:o.minContextSlot},a=await s.sendRawTransaction(e,i),c=o&&o.commitment,u=(await(n?s.confirmTransaction(n,c):s.confirmTransaction(a,c))).value;if(u.err)throw new Error(`Raw transaction ${a} failed (${JSON.stringify(u)})`);return a}const Ul=1e9,jl=Object.freeze(Object.defineProperty({__proto__:null,Account:Ac,AddressLookupTableAccount:nn,AddressLookupTableInstruction:Sl,AddressLookupTableProgram:Nn,Authorized:ti,BLOCKHASH_CACHE_TIMEOUT_MS:Fo,BPF_LOADER_DEPRECATED_PROGRAM_ID:Ec,BPF_LOADER_PROGRAM_ID:$c,BpfLoader:jc,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:Ye,ComputeBudgetInstruction:vl,ComputeBudgetProgram:Un,Connection:kl,Ed25519Program:_r,Enum:Ic,EpochSchedule:qo,FeeCalculatorLayout:Wo,Keypair:Lt,LAMPORTS_PER_SOL:Ul,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:it,Loader:St,Lockup:tr,MAX_SEED_LENGTH:zo,Message:Ve,MessageAccountKeys:Ht,MessageV0:kt,NONCE_ACCOUNT_LENGTH:tn,NonceAccount:Sr,PACKET_DATA_SIZE:pt,PUBLIC_KEY_LENGTH:Xe,PublicKey:P,SIGNATURE_LENGTH_IN_BYTES:jt,SOLANA_SCHEMA:Vt,STAKE_CONFIG_ID:ei,STAKE_INSTRUCTION_LAYOUTS:ge,SYSTEM_INSTRUCTION_LAYOUTS:ie,SYSVAR_CLOCK_PUBKEY:He,SYSVAR_EPOCH_SCHEDULE_PUBKEY:Nc,SYSVAR_INSTRUCTIONS_PUBKEY:Uc,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:ur,SYSVAR_RENT_PUBKEY:Ot,SYSVAR_REWARDS_PUBKEY:Kc,SYSVAR_SLOT_HASHES_PUBKEY:Wc,SYSVAR_SLOT_HISTORY_PUBKEY:Dc,SYSVAR_STAKE_HISTORY_PUBKEY:lr,Secp256k1Program:Ct,SendTransactionError:rn,SolanaJSONRPCError:M,SolanaJSONRPCErrorCode:Zc,StakeAuthorizationLayout:Rl,StakeInstruction:El,StakeProgram:Ar,Struct:Rn,SystemInstruction:Fc,SystemProgram:be,Transaction:re,TransactionExpiredBlockheightExceededError:xn,TransactionExpiredNonceInvalidError:Tt,TransactionExpiredTimeoutError:Bn,TransactionInstruction:oe,TransactionMessage:Tn,TransactionStatus:ot,VALIDATOR_INFO_KEY:ni,VERSION_PREFIX_MASK:wr,VOTE_PROGRAM_ID:Tl,ValidatorInfo:Kn,VersionedMessage:Pn,VersionedTransaction:Ln,VoteAccount:Wn,VoteAuthorizationLayout:Bl,VoteInit:ri,VoteInstruction:xl,VoteProgram:Dt,clusterApiUrl:zl,sendAndConfirmRawTransaction:Nl,sendAndConfirmTransaction:en},Symbol.toStringTag,{value:"Module"}));export{kl as C,$l as E,Lt as K,P,rn as S,oe as T,Pn as V,Ot as a,be as b,zl as c,He as d,re as e,Ln as f,jt as g,Nt as h,jl as i,ae as j,po as k,D as l,Un as m,q as s,ba as t,Q as u};
