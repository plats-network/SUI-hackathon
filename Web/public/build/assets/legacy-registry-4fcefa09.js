import{b as D}from"./index-ea9ea726.js";const j=t=>D.encode(t),M=t=>D.decode(t);function L(t){return Uint8Array.from(atob(t),e=>e.charCodeAt(0))}const V=8192;function U(t){if(t.length<V)return btoa(String.fromCharCode(...t));let e="";for(var r=0;r<t.length;r+=V){const n=t.slice(r,r+V);e+=String.fromCharCode(...n)}return btoa(e)}function P(t){var i;const e=t.startsWith("0x")?t.slice(2):t,n=((i=(e.length%2===0?e:`0${e}}`).match(/.{2}/g))==null?void 0:i.map(a=>parseInt(a,16)))??[];return Uint8Array.from(n)}function O(t){return t.reduce((e,r)=>e+r.toString(16).padStart(2,"0"),"")}function C(t){let e=[],r=0;if(t===0)return[0];for(;t>0;)e[r]=t&127,(t>>=7)&&(e[r]|=128),r+=1;return e}function q(t){let e=0,r=0,n=0;for(;;){let i=t[n];if(n+=1,e|=(i&127)<<r,!(i&128))break;r+=7}return{value:e,length:n}}class G{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),n=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+n).toString(10)}read128(){let e=BigInt(this.read64()),n=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+n).toString(10)}read256(){let e=BigInt(this.read128()),n=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+n).toString(10)}readBytes(e){let r=this.bytePosition+this.dataView.byteOffset,n=new Uint8Array(this.dataView.buffer,r,e);return this.shift(e),n}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,e),{value:n,length:i}=q(r);return this.shift(i),n}readVec(e){let r=this.readULEB(),n=[];for(let i=0;i<r;i++)n.push(e(this,i,r));return n}}function J(t,e){switch(e){case"base58":return j(t);case"base64":return U(t);case"hex":return O(t);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function Z(t,e){switch(e){case"base58":return M(t);case"base64":return L(t);case"hex":return P(t);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function F(t,e=["<",">"]){const[r,n]=e,i=[];let a="",c=0;for(let s=0;s<t.length;s++){const o=t[s];if(o===r&&c++,o===n&&c--,c===0&&o===","){i.push(a.trim()),a="";continue}a+=o}return i.push(a.trim()),i}class H{constructor({size:e=1024,maxSize:r,allocateSize:n=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=r||e,this.allocateSize=n,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const r=this.bytePosition+e;if(r>this.size){const n=Math.min(this.maxSize,this.size+this.allocateSize);if(r>n)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${r}`);this.size=n;const i=new ArrayBuffer(this.size);new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(i)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return N(BigInt(e),8).forEach(r=>this.write8(r)),this}write128(e){return N(BigInt(e),16).forEach(r=>this.write8(r)),this}write256(e){return N(BigInt(e),32).forEach(r=>this.write8(r)),this}writeULEB(e){return C(e).forEach(r=>this.write8(r)),this}writeVec(e,r){return this.writeULEB(e.length),Array.from(e).forEach((n,i)=>r(this,n,i,e.length)),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return J(this.toBytes(),e)}}function N(t,e){let r=new Uint8Array(e),n=0;for(;t>0;)r[n]=Number(t%BigInt(256)),t=t/BigInt(256),n+=1;return r}var W=(t,e,r)=>{if(!e.has(t))throw TypeError("Cannot "+r)},g=(t,e,r)=>(W(t,e,"read from private field"),r?r.call(t):e.get(t)),v=(t,e,r)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,r)},A=(t,e,r,n)=>(W(t,e,"write to private field"),n?n.call(t,r):e.set(t,r),r),S,$,x,T;const K=class{constructor(t){v(this,S,void 0),v(this,$,void 0),this.name=t.name,this.read=t.read,this.serializedSize=t.serializedSize??(()=>null),A(this,S,t.write),A(this,$,t.serialize??((e,r)=>{const n=new H({size:this.serializedSize(e)??void 0,...r});return g(this,S).call(this,e,n),n.toBytes()})),this.validate=t.validate??(()=>{})}write(t,e){this.validate(t),g(this,S).call(this,t,e)}serialize(t,e){return this.validate(t),new Q(this,g(this,$).call(this,t,e))}parse(t){const e=new G(t);return this.read(e)}transform({name:t,input:e,output:r}){return new K({name:t??this.name,read:n=>r(this.read(n)),write:(n,i)=>g(this,S).call(this,e(n),i),serializedSize:n=>this.serializedSize(e(n)),serialize:(n,i)=>g(this,$).call(this,e(n),i),validate:n=>this.validate(e(n))})}};let p=K;S=new WeakMap;$=new WeakMap;const X=Symbol.for("@mysten/serialized-bcs");function ae(t){return!!t&&typeof t=="object"&&t[X]===!0}class Q{constructor(e,r){v(this,x,void 0),v(this,T,void 0),A(this,x,e),A(this,T,r)}get[X](){return!0}toBytes(){return g(this,T)}toHex(){return O(g(this,T))}toBase64(){return U(g(this,T))}toBase58(){return j(g(this,T))}parse(){return g(this,x).parse(g(this,T))}}x=new WeakMap;T=new WeakMap;function I({size:t,...e}){return new p({...e,serializedSize:()=>t})}function _({readMethod:t,writeMethod:e,...r}){return I({...r,read:n=>n[t](),write:(n,i)=>i[e](n),validate:n=>{var i;if(n<0||n>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${n}. Expected value in range 0-${r.maxValue}`);(i=r.validate)==null||i.call(r,n)}})}function k({readMethod:t,writeMethod:e,...r}){return I({...r,read:n=>n[t](),write:(n,i)=>i[e](BigInt(n)),validate:n=>{var a;const i=BigInt(n);if(i<0||i>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${i}. Expected value in range 0-${r.maxValue}`);(a=r.validate)==null||a.call(r,i)}})}function Y({serialize:t,...e}){const r=new p({...e,serialize:t,write:(n,i)=>{for(const a of r.serialize(n).toBytes())i.write8(a)}});return r}function ee({toBytes:t,fromBytes:e,...r}){return new p({...r,read:n=>{const i=n.readULEB(),a=n.readBytes(i);return e(a)},write:(n,i)=>{const a=t(n);i.writeULEB(a.length);for(let c=0;c<a.length;c++)i.write8(a[c])},serialize:n=>{const i=t(n),a=C(i.length),c=new Uint8Array(a.length+i.length);return c.set(a,0),c.set(i,a.length),c},validate:n=>{var i;if(typeof n!="string")throw new TypeError(`Invalid ${r.name} value: ${n}. Expected string`);(i=r.validate)==null||i.call(r,n)}})}function te(t){let e=null;function r(){return e||(e=t()),e}return new p({name:"lazy",read:n=>r().read(n),serializedSize:n=>r().serializedSize(n),write:(n,i)=>r().write(n,i),serialize:(n,i)=>r().serialize(n,i).toBytes()})}const R={u8(t){return _({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...t})},u16(t){return _({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...t})},u32(t){return _({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...t})},u64(t){return k({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...t})},u128(t){return k({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...t})},u256(t){return k({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...t})},bool(t){return I({name:"bool",size:1,read:e=>e.read8()===1,write:(e,r)=>r.write8(e?1:0),...t,validate:e=>{var r;if((r=t==null?void 0:t.validate)==null||r.call(t,e),typeof e!="boolean")throw new TypeError(`Expected boolean, found ${typeof e}`)}})},uleb128(t){return Y({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(C(e)),...t})},bytes(t,e){return I({name:`bytes[${t}]`,size:t,read:r=>r.readBytes(t),write:(r,n)=>{for(let i=0;i<t;i++)n.write8(r[i]??0)},...e,validate:r=>{var n;if((n=e==null?void 0:e.validate)==null||n.call(e,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==t)throw new TypeError(`Expected array of length ${t}, found ${r.length}`)}})},string(t){return ee({name:"string",toBytes:e=>new TextEncoder().encode(e),fromBytes:e=>new TextDecoder().decode(e),...t})},fixedArray(t,e,r){return new p({name:`${e.name}[${t}]`,read:n=>{const i=new Array(t);for(let a=0;a<t;a++)i[a]=e.read(n);return i},write:(n,i)=>{for(const a of n)e.write(a,i)},...r,validate:n=>{var i;if((i=r==null?void 0:r.validate)==null||i.call(r,n),!("length"in n))throw new TypeError(`Expected array, found ${typeof n}`);if(n.length!==t)throw new TypeError(`Expected array of length ${t}, found ${n.length}`)}})},option(t){return R.enum(`Option<${t.name}>`,{None:null,Some:t}).transform({input:e=>e==null?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null})},vector(t,e){return new p({name:`vector<${t.name}>`,read:r=>{const n=r.readULEB(),i=new Array(n);for(let a=0;a<n;a++)i[a]=t.read(r);return i},write:(r,n)=>{n.writeULEB(r.length);for(const i of r)t.write(i,n)},...e,validate:r=>{var n;if((n=e==null?void 0:e.validate)==null||n.call(e,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`)}})},tuple(t,e){return new p({name:`(${t.map(r=>r.name).join(", ")})`,serializedSize:r=>{let n=0;for(let i=0;i<t.length;i++){const a=t[i].serializedSize(r[i]);if(a==null)return null;n+=a}return n},read:r=>{const n=[];for(const i of t)n.push(i.read(r));return n},write:(r,n)=>{for(let i=0;i<t.length;i++)t[i].write(r[i],n)},...e,validate:r=>{var n;if((n=e==null?void 0:e.validate)==null||n.call(e,r),!Array.isArray(r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==t.length)throw new TypeError(`Expected array of length ${t.length}, found ${r.length}`)}})},struct(t,e,r){const n=Object.entries(e);return new p({name:t,serializedSize:i=>{let a=0;for(const[c,s]of n){const o=s.serializedSize(i[c]);if(o==null)return null;a+=o}return a},read:i=>{const a={};for(const[c,s]of n)a[c]=s.read(i);return a},write:(i,a)=>{for(const[c,s]of n)s.write(i[c],a)},...r,validate:i=>{var a;if((a=r==null?void 0:r.validate)==null||a.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})},enum(t,e,r){const n=Object.entries(e);return new p({name:t,read:i=>{const a=i.readULEB(),[c,s]=n[a];return{[c]:(s==null?void 0:s.read(i))??!0}},write:(i,a)=>{const[c,s]=Object.entries(i)[0];for(let o=0;o<n.length;o++){const[l,h]=n[o];if(l===c){a.writeULEB(o),h==null||h.write(s,a);return}}},...r,validate:i=>{var s;if((s=r==null?void 0:r.validate)==null||s.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`);const a=Object.keys(i);if(a.length!==1)throw new TypeError(`Expected object with one key, found ${a.length}`);const[c]=a;if(!Object.hasOwn(e,c))throw new TypeError(`Invalid enum variant ${c}`)}})},map(t,e){return R.vector(R.tuple([t,e])).transform({name:`Map<${t.name}, ${e.name}>`,input:r=>[...r.entries()],output:r=>{const n=new Map;for(const[i,a]of r)n.set(i,a);return n}})},generic(t,e){return(...r)=>e(...r).transform({name:`${e.name}<${r.map(n=>n.name).join(", ")}>`,input:n=>n,output:n=>n})},lazy(t){return te(t)}},re=32,z=class{constructor(t){if(this.types=new Map,this.counter=0,t instanceof z){this.schema=t.schema,this.types=new Map(t.types);return}if(this.schema=t,this.registerAddressType(z.ADDRESS,t.addressLength,t.addressEncoding),this.registerVectorType(t.vectorType),t.types&&t.types.structs)for(let e of Object.keys(t.types.structs))this.registerStructType(e,t.types.structs[e]);if(t.types&&t.types.enums)for(let e of Object.keys(t.types.enums))this.registerEnumType(e,t.types.enums[e]);if(t.types&&t.types.aliases)for(let e of Object.keys(t.types.aliases))this.registerAlias(e,t.types.aliases[e]);t.withPrimitives!==!1&&ne(this)}tempKey(){return`bcs-struct-${++this.counter}`}ser(t,e,r){if(typeof t=="string"||Array.isArray(t)){const{name:n,params:i}=this.parseTypeName(t);return this.getTypeInterface(n).encode(this,e,r,i)}if(typeof t=="object"){const n=this.tempKey();return new z(this).registerStructType(n,t).ser(n,e,r)}throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(t)}`)}de(t,e,r){if(typeof e=="string")if(r)e=Z(e,r);else throw new Error("To pass a string to `bcs.de`, specify encoding");if(typeof t=="string"||Array.isArray(t)){const{name:n,params:i}=this.parseTypeName(t);return this.getTypeInterface(n).decode(this,e,i)}if(typeof t=="object"){const n=new z(this),i=this.tempKey();return n.registerStructType(i,t).de(i,e,r)}throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(t)}`)}hasType(t){return this.types.has(t)}registerAlias(t,e){return this.types.set(t,e),this}registerType(t,e,r,n=()=>!0){const{name:i,params:a}=this.parseTypeName(t);return this.types.set(i,{encode(c,s,o,l){const h=a.reduce((u,d,y)=>Object.assign(u,{[d]:l[y]}),{});return this._encodeRaw.call(c,new H(o),s,l,h)},decode(c,s,o){const l=a.reduce((h,u,d)=>Object.assign(h,{[u]:o[d]}),{});return this._decodeRaw.call(c,new G(s),o,l)},_encodeRaw(c,s,o,l){if(n(s))return e.call(this,c,s,o,l);throw new Error(`Validation failed for type ${i}, data: ${s}`)},_decodeRaw(c,s,o){return r.call(this,c,s,o)}}),this}registerBcsType(t,e){return this.registerType(t,(r,n,i)=>{const a=i.map(c=>new p({name:String(c),write:(s,o)=>{const{name:l,params:h}=this.parseTypeName(c),u=this.getTypeInterface(l),d=h.reduce((y,m,w)=>Object.assign(y,{[m]:i[w]}),{});return u._encodeRaw.call(this,o,s,h,d)},read:()=>{throw new Error("Not implemented")}}));return e(...a).write(n,r),r},(r,n)=>{const i=n.map(a=>new p({name:String(a),write:(c,s)=>{throw new Error("Not implemented")},read:c=>{const{name:s,params:o}=this.parseTypeName(a),l=this.getTypeInterface(s),h=o.reduce((u,d,y)=>Object.assign(u,{[d]:n[y]}),{});return l._decodeRaw.call(this,c,o,h)}}));return e(...i).read(r)}),this}registerAddressType(t,e,r="hex"){switch(r){case"base64":return this.registerType(t,function(i,a){return L(a).reduce((c,s)=>c.write8(s),i)},function(i){return U(i.readBytes(e))});case"hex":return this.registerType(t,function(i,a){return P(a).reduce((c,s)=>c.write8(s),i)},function(i){return O(i.readBytes(e))});default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(t){let{name:e,params:r}=this.parseTypeName(t);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+e);return this.registerType(t,function(i,a,c,s){return i.writeVec(a,(o,l)=>{let h=c[0];if(!h)throw new Error(`Incorrect number of type parameters passed a to vector '${t}'`);let{name:u,params:d}=this.parseTypeName(h);if(this.hasType(u))return this.getTypeInterface(u)._encodeRaw.call(this,o,l,d,s);if(!(u in s))throw new Error(`Unable to find a matching type definition for ${u} in vector; make sure you passed a generic`);let{name:y,params:m}=this.parseTypeName(s[u]);return this.getTypeInterface(y)._encodeRaw.call(this,o,l,m,s)})},function(i,a,c){return i.readVec(s=>{let o=a[0];if(!o)throw new Error(`Incorrect number of type parameters passed to a vector '${t}'`);let{name:l,params:h}=this.parseTypeName(o);if(this.hasType(l))return this.getTypeInterface(l)._decodeRaw.call(this,s,h,c);if(!(l in c))throw new Error(`Unable to find a matching type definition for ${l} in vector; make sure you passed a generic`);let{name:u,params:d}=this.parseTypeName(c[l]);return this.getTypeInterface(u)._decodeRaw.call(this,s,d,c)})})}registerStructType(t,e){for(let c in e){let s=this.tempKey(),o=e[c];!Array.isArray(o)&&typeof o!="string"&&(e[c]=s,this.registerStructType(s,o))}let r=Object.freeze(e),n=Object.keys(r),{name:i,params:a}=this.parseTypeName(t);return this.registerType(t,function(s,o,l,h){if(!o||o.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${o}`);if(l.length!==a.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${a.length}, got: ${l.length}`);for(let u of n){if(!(u in o))throw new Error(`Struct ${i} requires field ${u}:${r[u]}`);const{name:d,params:y}=this.parseTypeName(r[u]);if(!a.includes(d))this.getTypeInterface(d)._encodeRaw.call(this,s,o[u],y,h);else{const m=a.indexOf(d);let{name:w,params:E}=this.parseTypeName(l[m]);if(this.hasType(w)){this.getTypeInterface(w)._encodeRaw.call(this,s,o[u],E,h);continue}if(!(w in h))throw new Error(`Unable to find a matching type definition for ${w} in ${i}; make sure you passed a generic`);let{name:b,params:B}=this.parseTypeName(h[w]);this.getTypeInterface(b)._encodeRaw.call(this,s,o[u],B,h)}}return s},function(s,o,l){if(o.length!==a.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${a.length}, got: ${o.length}`);let h={};for(let u of n){const{name:d,params:y}=this.parseTypeName(r[u]);if(!a.includes(d))h[u]=this.getTypeInterface(d)._decodeRaw.call(this,s,y,l);else{const m=a.indexOf(d);let{name:w,params:E}=this.parseTypeName(o[m]);if(this.hasType(w)){h[u]=this.getTypeInterface(w)._decodeRaw.call(this,s,E,l);continue}if(!(w in l))throw new Error(`Unable to find a matching type definition for ${w} in ${i}; make sure you passed a generic`);let{name:b,params:B}=this.parseTypeName(l[w]);h[u]=this.getTypeInterface(b)._decodeRaw.call(this,s,B,l)}}return h})}registerEnumType(t,e){for(let c in e){let s=this.tempKey(),o=e[c];o!==null&&!Array.isArray(o)&&typeof o!="string"&&(e[c]=s,this.registerStructType(s,o))}let r=Object.freeze(e),n=Object.keys(r),{name:i,params:a}=this.parseTypeName(t);return this.registerType(t,function(s,o,l,h){if(!o)throw new Error(`Unable to write enum "${i}", missing data.
Received: "${o}"`);if(typeof o!="object")throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".
Received: "${JSON.stringify(o)}"`);let u=Object.keys(o)[0];if(u===void 0)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let d=n.indexOf(u);if(d===-1)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${u}"`);let y=n[d],m=r[y];if(s.write8(d),m===null)return s;let w=a.indexOf(m),E=w===-1?m:l[w];{let{name:b,params:B}=this.parseTypeName(E);return this.getTypeInterface(b)._encodeRaw.call(this,s,o[u],B,h)}},function(s,o,l){let h=s.readULEB(),u=n[h],d=r[u];if(h===-1)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${h}"`);if(d===null)return{[u]:!0};let y=a.indexOf(d),m=y===-1?d:o[y];{let{name:w,params:E}=this.parseTypeName(m);return{[u]:this.getTypeInterface(w)._decodeRaw.call(this,s,E,l)}}})}getTypeInterface(t){let e=this.types.get(t);if(typeof e=="string"){let r=[];for(;typeof e=="string";){if(r.includes(e))throw new Error(`Recursive definition found: ${r.join(" -> ")} -> ${e}`);r.push(e),e=this.types.get(e)}}if(e===void 0)throw new Error(`Type ${t} is not registered`);return e}parseTypeName(t){if(Array.isArray(t)){let[s,...o]=t;return{name:s,params:o}}if(typeof t!="string")throw new Error(`Illegal type passed as a name of the type: ${t}`);let[e,r]=this.schema.genericSeparators||["<",">"],n=t.indexOf(e),i=Array.from(t).reverse().indexOf(r);if(n===-1&&i===-1)return{name:t,params:[]};if(n===-1||i===-1)throw new Error(`Unclosed generic in name '${t}'`);let a=t.slice(0,n),c=F(t.slice(n+1,t.length-i-1),this.schema.genericSeparators);return{name:a,params:c}}};let f=z;f.U8="u8";f.U16="u16";f.U32="u32";f.U64="u64";f.U128="u128";f.U256="u256";f.BOOL="bool";f.VECTOR="vector";f.ADDRESS="address";f.STRING="string";f.HEX="hex-string";f.BASE58="base58-string";f.BASE64="base64-string";function ne(t){t.registerType(f.U8,function(e,r){return e.write8(r)},function(e){return e.read8()},e=>e<256),t.registerType(f.U16,function(e,r){return e.write16(r)},function(e){return e.read16()},e=>e<65536),t.registerType(f.U32,function(e,r){return e.write32(r)},function(e){return e.read32()},e=>e<=4294967296n),t.registerType(f.U64,function(e,r){return e.write64(r)},function(e){return e.read64()}),t.registerType(f.U128,function(e,r){return e.write128(r)},function(e){return e.read128()}),t.registerType(f.U256,function(e,r){return e.write256(r)},function(e){return e.read256()}),t.registerType(f.BOOL,function(e,r){return e.write8(r)},function(e){return e.read8().toString(10)==="1"}),t.registerType(f.STRING,function(e,r){return e.writeVec(Array.from(r),(n,i)=>n.write8(i.charCodeAt(0)))},function(e){return e.readVec(r=>r.read8()).map(r=>String.fromCharCode(Number(r))).join("")},e=>!0),t.registerType(f.HEX,function(e,r){return e.writeVec(Array.from(P(r)),(n,i)=>n.write8(i))},function(e){let r=e.readVec(n=>n.read8());return O(new Uint8Array(r))}),t.registerType(f.BASE58,function(e,r){return e.writeVec(Array.from(M(r)),(n,i)=>n.write8(i))},function(e){let r=e.readVec(n=>n.read8());return j(new Uint8Array(r))}),t.registerType(f.BASE64,function(e,r){return e.writeVec(Array.from(L(r)),(n,i)=>n.write8(i))},function(e){let r=e.readVec(n=>n.read8());return U(new Uint8Array(r))})}function se(){return{genericSeparators:["<",">"],vectorType:"vector",addressLength:re,addressEncoding:"hex"}}export{f as B,U as a,R as b,P as c,j as d,L as e,M as f,se as g,ae as i,F as s,O as t};
