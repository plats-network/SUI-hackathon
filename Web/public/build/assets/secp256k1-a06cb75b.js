import{w as Ft,H as Gt,C as Pt,g as F,M as Dt,h as Wt,j as Xt,r as Qt}from"./_md-5eb5ac83.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ht=BigInt(0),bt=BigInt(1),Jt=BigInt(2);function it(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function gt(n){if(!it(n))throw new Error("Uint8Array expected")}const tn=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function at(n){gt(n);let e="";for(let t=0;t<n.length;t++)e+=tn[n[t]];return e}function zt(n){const e=n.toString(16);return e.length&1?`0${e}`:e}function St(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const G={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function $t(n){if(n>=G._0&&n<=G._9)return n-G._0;if(n>=G._A&&n<=G._F)return n-(G._A-10);if(n>=G._a&&n<=G._f)return n-(G._a-10)}function ut(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let i=0,c=0;i<t;i++,c+=2){const d=$t(n.charCodeAt(c)),s=$t(n.charCodeAt(c+1));if(d===void 0||s===void 0){const o=n[c]+n[c+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+c)}r[i]=d*16+s}return r}function ot(n){return St(at(n))}function It(n){return gt(n),St(at(Uint8Array.from(n).reverse()))}function lt(n,e){return ut(n.toString(16).padStart(e*2,"0"))}function At(n,e){return lt(n,e).reverse()}function nn(n){return ut(zt(n))}function M(n,e,t){let r;if(typeof e=="string")try{r=ut(e)}catch(c){throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${c}`)}else if(it(e))r=Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(`${n} expected ${t} bytes, got ${i}`);return r}function ht(...n){let e=0;for(let r=0;r<n.length;r++){const i=n[r];gt(i),e+=i.length}const t=new Uint8Array(e);for(let r=0,i=0;r<n.length;r++){const c=n[r];t.set(c,i),i+=c.length}return t}function en(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}function rn(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function on(n){let e;for(e=0;n>Ht;n>>=bt,e+=1);return e}function sn(n,e){return n>>BigInt(e)&bt}function cn(n,e,t){return n|(t?bt:Ht)<<BigInt(e)}const qt=n=>(Jt<<BigInt(n-1))-bt,pt=n=>new Uint8Array(n),Tt=n=>Uint8Array.from(n);function Vt(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=pt(n),i=pt(n),c=0;const d=()=>{r.fill(1),i.fill(0),c=0},s=(...l)=>t(i,r,...l),o=(l=pt())=>{i=s(Tt([0]),l),r=s(),l.length!==0&&(i=s(Tt([1]),l),r=s())},a=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const I=[];for(;l<e;){r=s();const A=r.slice();I.push(A),l+=r.length}return ht(...I)};return(l,I)=>{d(),o(l);let A;for(;!(A=I(a()));)o();return d(),A}}const fn={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||it(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function wt(n,e,t={}){const r=(i,c,d)=>{const s=fn[c];if(typeof s!="function")throw new Error(`Invalid validator "${c}", expected function`);const o=n[i];if(!(d&&o===void 0)&&!s(o,n))throw new Error(`Invalid param ${String(i)}=${o} (${typeof o}), expected ${c}`)};for(const[i,c]of Object.entries(e))r(i,c,!1);for(const[i,c]of Object.entries(t))r(i,c,!0);return n}const an=Object.freeze(Object.defineProperty({__proto__:null,abytes:gt,bitGet:sn,bitLen:on,bitMask:qt,bitSet:cn,bytesToHex:at,bytesToNumberBE:ot,bytesToNumberLE:It,concatBytes:ht,createHmacDrbg:Vt,ensureBytes:M,equalBytes:en,hexToBytes:ut,hexToNumber:St,isBytes:it,numberToBytesBE:lt,numberToBytesLE:At,numberToHexUnpadded:zt,numberToVarBytesBE:nn,utf8ToBytes:rn,validateObject:wt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const U=BigInt(0),T=BigInt(1),et=BigInt(2),un=BigInt(3),Et=BigInt(4),Ct=BigInt(5),Ut=BigInt(8);BigInt(9);BigInt(16);function Z(n,e){const t=n%e;return t>=U?t:e+t}function ln(n,e,t){if(t<=U||e<U)throw new Error("Expected power/modulo > 0");if(t===T)return U;let r=T;for(;e>U;)e&T&&(r=r*n%t),n=n*n%t,e>>=T;return r}function j(n,e,t){let r=n;for(;e-- >U;)r*=r,r%=t;return r}function xt(n,e){if(n===U||e<=U)throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);let t=Z(n,e),r=e,i=U,c=T;for(;t!==U;){const s=r/t,o=r%t,a=i-c*s;r=t,t=o,i=c,c=a}if(r!==T)throw new Error("invert: does not exist");return Z(i,e)}function dn(n){const e=(n-T)/et;let t,r,i;for(t=n-T,r=0;t%et===U;t/=et,r++);for(i=et;i<n&&ln(i,e,n)!==n-T;i++);if(r===1){const d=(n+T)/Et;return function(o,a){const b=o.pow(a,d);if(!o.eql(o.sqr(b),a))throw new Error("Cannot find square root");return b}}const c=(t+T)/et;return function(s,o){if(s.pow(o,e)===s.neg(s.ONE))throw new Error("Cannot find square root");let a=r,b=s.pow(s.mul(s.ONE,i),t),l=s.pow(o,c),I=s.pow(o,t);for(;!s.eql(I,s.ONE);){if(s.eql(I,s.ZERO))return s.ZERO;let A=1;for(let f=s.sqr(I);A<a&&!s.eql(f,s.ONE);A++)f=s.sqr(f);const p=s.pow(b,T<<BigInt(a-A-1));b=s.sqr(p),l=s.mul(l,p),I=s.mul(I,b),a=A}return l}}function hn(n){if(n%Et===un){const e=(n+T)/Et;return function(r,i){const c=r.pow(i,e);if(!r.eql(r.sqr(c),i))throw new Error("Cannot find square root");return c}}if(n%Ut===Ct){const e=(n-Ct)/Ut;return function(r,i){const c=r.mul(i,et),d=r.pow(c,e),s=r.mul(i,d),o=r.mul(r.mul(s,et),d),a=r.mul(s,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),i))throw new Error("Cannot find square root");return a}}return dn(n)}const Ln=(n,e)=>(Z(n,e)&T)===T,gn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function wn(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=gn.reduce((r,i)=>(r[i]="function",r),e);return wt(n,t)}function bn(n,e,t){if(t<U)throw new Error("Expected power > 0");if(t===U)return n.ONE;if(t===T)return e;let r=n.ONE,i=e;for(;t>U;)t&T&&(r=n.mul(r,i)),i=n.sqr(i),t>>=T;return r}function yn(n,e){const t=new Array(e.length),r=e.reduce((c,d,s)=>n.is0(d)?c:(t[s]=c,n.mul(c,d)),n.ONE),i=n.inv(r);return e.reduceRight((c,d,s)=>n.is0(d)?c:(t[s]=n.mul(c,t[s]),n.mul(c,d)),i),t}function jt(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function pn(n,e,t=!1,r={}){if(n<=U)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:i,nByteLength:c}=jt(n,e);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const d=hn(n),s=Object.freeze({ORDER:n,BITS:i,BYTES:c,MASK:qt(i),ZERO:U,ONE:T,create:o=>Z(o,n),isValid:o=>{if(typeof o!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);return U<=o&&o<n},is0:o=>o===U,isOdd:o=>(o&T)===T,neg:o=>Z(-o,n),eql:(o,a)=>o===a,sqr:o=>Z(o*o,n),add:(o,a)=>Z(o+a,n),sub:(o,a)=>Z(o-a,n),mul:(o,a)=>Z(o*a,n),pow:(o,a)=>bn(s,o,a),div:(o,a)=>Z(o*xt(a,n),n),sqrN:o=>o*o,addN:(o,a)=>o+a,subN:(o,a)=>o-a,mulN:(o,a)=>o*a,inv:o=>xt(o,n),sqrt:r.sqrt||(o=>d(s,o)),invertBatch:o=>yn(s,o),cmov:(o,a,b)=>b?a:o,toBytes:o=>t?At(o,c):lt(o,c),fromBytes:o=>{if(o.length!==c)throw new Error(`Fp.fromBytes: expected ${c}, got ${o.length}`);return t?It(o):ot(o)}});return Object.freeze(s)}function Hn(n,e){if(!n.isOdd)throw new Error("Field doesn't have isOdd");const t=n.sqrt(e);return n.isOdd(t)?n.neg(t):t}function kt(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function Yt(n){const e=kt(n);return e+Math.ceil(e/2)}function mn(n,e,t=!1){const r=n.length,i=kt(e),c=Yt(e);if(r<16||r<c||r>1024)throw new Error(`expected ${c}-1024 bytes of input, got ${r}`);const d=t?ot(n):It(n),s=Z(d,e-T)+T;return t?At(s,i):lt(s,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const En=BigInt(0),mt=BigInt(1);function xn(n,e){const t=(i,c)=>{const d=c.negate();return i?d:c},r=i=>{const c=Math.ceil(e/i)+1,d=2**(i-1);return{windows:c,windowSize:d}};return{constTimeNegate:t,unsafeLadder(i,c){let d=n.ZERO,s=i;for(;c>En;)c&mt&&(d=d.add(s)),s=s.double(),c>>=mt;return d},precomputeWindow(i,c){const{windows:d,windowSize:s}=r(c),o=[];let a=i,b=a;for(let l=0;l<d;l++){b=a,o.push(b);for(let I=1;I<s;I++)b=b.add(a),o.push(b);a=b.double()}return o},wNAF(i,c,d){const{windows:s,windowSize:o}=r(i);let a=n.ZERO,b=n.BASE;const l=BigInt(2**i-1),I=2**i,A=BigInt(i);for(let p=0;p<s;p++){const f=p*o;let h=Number(d&l);d>>=A,h>o&&(h-=I,d+=mt);const g=f,m=f+Math.abs(h)-1,x=p%2!==0,q=h<0;h===0?b=b.add(t(x,c[g])):a=a.add(t(q,c[m]))}return{p:a,f:b}},wNAFCached(i,c,d,s){const o=i._WINDOW_SIZE||1;let a=c.get(i);return a||(a=this.precomputeWindow(i,o),o!==1&&c.set(i,s(a))),this.wNAF(o,a,d)}}}function Kt(n){return wn(n.Fp),wt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...jt(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}const Bn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),J=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),tt=new Uint32Array(64);class vn extends Gt{constructor(){super(64,32,8,!1),this.A=J[0]|0,this.B=J[1]|0,this.C=J[2]|0,this.D=J[3]|0,this.E=J[4]|0,this.F=J[5]|0,this.G=J[6]|0,this.H=J[7]|0}get(){const{A:e,B:t,C:r,D:i,E:c,F:d,G:s,H:o}=this;return[e,t,r,i,c,d,s,o]}set(e,t,r,i,c,d,s,o){this.A=e|0,this.B=t|0,this.C=r|0,this.D=i|0,this.E=c|0,this.F=d|0,this.G=s|0,this.H=o|0}process(e,t){for(let l=0;l<16;l++,t+=4)tt[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const I=tt[l-15],A=tt[l-2],p=F(I,7)^F(I,18)^I>>>3,f=F(A,17)^F(A,19)^A>>>10;tt[l]=f+tt[l-7]+p+tt[l-16]|0}let{A:r,B:i,C:c,D:d,E:s,F:o,G:a,H:b}=this;for(let l=0;l<64;l++){const I=F(s,6)^F(s,11)^F(s,25),A=b+I+Pt(s,o,a)+Bn[l]+tt[l]|0,f=(F(r,2)^F(r,13)^F(r,22))+Dt(r,i,c)|0;b=a,a=o,o=s,s=d+A|0,d=c,c=i,i=r,r=A+f|0}r=r+this.A|0,i=i+this.B|0,c=c+this.C|0,d=d+this.D|0,s=s+this.E|0,o=o+this.F|0,a=a+this.G|0,b=b+this.H|0,this.set(r,i,c,d,s,o,a,b)}roundClean(){tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Sn=Ft(()=>new vn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function In(n){const e=Kt(n);wt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:i}=e;if(t){if(!r.eql(i,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:An,hexToBytes:qn}=an,rt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=rt;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:An(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=rt,t=typeof n=="string"?qn(n):n;gt(t);let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:i,l:c}=rt._parseInt(t.subarray(2)),{d,l:s}=rt._parseInt(c);if(s.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s:d}},hexFromSig(n){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,t=a=>{const b=a.toString(16);return b.length&1?`0${b}`:b},r=e(t(n.s)),i=e(t(n.r)),c=r.length/2,d=i.length/2,s=t(c),o=t(d);return`30${t(d+c+4)}02${o}${i}02${s}${r}`}},P=BigInt(0),k=BigInt(1);BigInt(2);const Zt=BigInt(3);BigInt(4);function On(n){const e=In(n),{Fp:t}=e,r=e.toBytes||((p,f,h)=>{const g=f.toAffine();return ht(Uint8Array.from([4]),t.toBytes(g.x),t.toBytes(g.y))}),i=e.fromBytes||(p=>{const f=p.subarray(1),h=t.fromBytes(f.subarray(0,t.BYTES)),g=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:h,y:g}});function c(p){const{a:f,b:h}=e,g=t.sqr(p),m=t.mul(g,p);return t.add(t.add(m,t.mul(p,f)),h)}if(!t.eql(t.sqr(e.Gy),c(e.Gx)))throw new Error("bad generator point: equation left != right");function d(p){return typeof p=="bigint"&&P<p&&p<e.n}function s(p){if(!d(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function o(p){const{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:g,n:m}=e;if(f&&typeof p!="bigint"){if(it(p)&&(p=at(p)),typeof p!="string"||!f.includes(p.length))throw new Error("Invalid key");p=p.padStart(h*2,"0")}let x;try{x=typeof p=="bigint"?p:ot(M("private key",p,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof p}`)}return g&&(x=Z(x,m)),s(x),x}const a=new Map;function b(p){if(!(p instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(f,h,g){if(this.px=f,this.py=h,this.pz=g,f==null||!t.isValid(f))throw new Error("x required");if(h==null||!t.isValid(h))throw new Error("y required");if(g==null||!t.isValid(g))throw new Error("z required")}static fromAffine(f){const{x:h,y:g}=f||{};if(!f||!t.isValid(h)||!t.isValid(g))throw new Error("invalid affine point");if(f instanceof l)throw new Error("projective point not allowed");const m=x=>t.eql(x,t.ZERO);return m(h)&&m(g)?l.ZERO:new l(h,g,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const h=t.invertBatch(f.map(g=>g.pz));return f.map((g,m)=>g.toAffine(h[m])).map(l.fromAffine)}static fromHex(f){const h=l.fromAffine(i(M("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return l.BASE.multiply(o(f))}_setWindowSize(f){this._WINDOW_SIZE=f,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=this.toAffine();if(!t.isValid(f)||!t.isValid(h))throw new Error("bad point: x or y not FE");const g=t.sqr(h),m=c(f);if(!t.eql(g,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){b(f);const{px:h,py:g,pz:m}=this,{px:x,py:q,pz:S}=f,y=t.eql(t.mul(h,S),t.mul(x,m)),E=t.eql(t.mul(g,S),t.mul(q,m));return y&&E}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:h}=e,g=t.mul(h,Zt),{px:m,py:x,pz:q}=this;let S=t.ZERO,y=t.ZERO,E=t.ZERO,v=t.mul(m,m),V=t.mul(x,x),$=t.mul(q,q),O=t.mul(m,x);return O=t.add(O,O),E=t.mul(m,q),E=t.add(E,E),S=t.mul(f,E),y=t.mul(g,$),y=t.add(S,y),S=t.sub(V,y),y=t.add(V,y),y=t.mul(S,y),S=t.mul(O,S),E=t.mul(g,E),$=t.mul(f,$),O=t.sub(v,$),O=t.mul(f,O),O=t.add(O,E),E=t.add(v,v),v=t.add(E,v),v=t.add(v,$),v=t.mul(v,O),y=t.add(y,v),$=t.mul(x,q),$=t.add($,$),v=t.mul($,O),S=t.sub(S,v),E=t.mul($,V),E=t.add(E,E),E=t.add(E,E),new l(S,y,E)}add(f){b(f);const{px:h,py:g,pz:m}=this,{px:x,py:q,pz:S}=f;let y=t.ZERO,E=t.ZERO,v=t.ZERO;const V=e.a,$=t.mul(e.b,Zt);let O=t.mul(h,x),H=t.mul(g,q),z=t.mul(m,S),D=t.add(h,g),u=t.add(x,q);D=t.mul(D,u),u=t.add(O,H),D=t.sub(D,u),u=t.add(h,m);let w=t.add(x,S);return u=t.mul(u,w),w=t.add(O,z),u=t.sub(u,w),w=t.add(g,m),y=t.add(q,S),w=t.mul(w,y),y=t.add(H,z),w=t.sub(w,y),v=t.mul(V,u),y=t.mul($,z),v=t.add(y,v),y=t.sub(H,v),v=t.add(H,v),E=t.mul(y,v),H=t.add(O,O),H=t.add(H,O),z=t.mul(V,z),u=t.mul($,u),H=t.add(H,z),z=t.sub(O,z),z=t.mul(V,z),u=t.add(u,z),O=t.mul(H,u),E=t.add(E,O),O=t.mul(w,u),y=t.mul(D,y),y=t.sub(y,O),O=t.mul(D,H),v=t.mul(w,v),v=t.add(v,O),new l(y,E,v)}subtract(f){return this.add(f.negate())}is0(){return this.equals(l.ZERO)}wNAF(f){return A.wNAFCached(this,a,f,h=>{const g=t.invertBatch(h.map(m=>m.pz));return h.map((m,x)=>m.toAffine(g[x])).map(l.fromAffine)})}multiplyUnsafe(f){const h=l.ZERO;if(f===P)return h;if(s(f),f===k)return this;const{endo:g}=e;if(!g)return A.unsafeLadder(this,f);let{k1neg:m,k1:x,k2neg:q,k2:S}=g.splitScalar(f),y=h,E=h,v=this;for(;x>P||S>P;)x&k&&(y=y.add(v)),S&k&&(E=E.add(v)),v=v.double(),x>>=k,S>>=k;return m&&(y=y.negate()),q&&(E=E.negate()),E=new l(t.mul(E.px,g.beta),E.py,E.pz),y.add(E)}multiply(f){s(f);let h=f,g,m;const{endo:x}=e;if(x){const{k1neg:q,k1:S,k2neg:y,k2:E}=x.splitScalar(h);let{p:v,f:V}=this.wNAF(S),{p:$,f:O}=this.wNAF(E);v=A.constTimeNegate(q,v),$=A.constTimeNegate(y,$),$=new l(t.mul($.px,x.beta),$.py,$.pz),g=v.add($),m=V.add(O)}else{const{p:q,f:S}=this.wNAF(h);g=q,m=S}return l.normalizeZ([g,m])[0]}multiplyAndAddUnsafe(f,h,g){const m=l.BASE,x=(S,y)=>y===P||y===k||!S.equals(m)?S.multiplyUnsafe(y):S.multiply(y),q=x(this,h).add(x(f,g));return q.is0()?void 0:q}toAffine(f){const{px:h,py:g,pz:m}=this,x=this.is0();f==null&&(f=x?t.ONE:t.inv(m));const q=t.mul(h,f),S=t.mul(g,f),y=t.mul(m,f);if(x)return{x:t.ZERO,y:t.ZERO};if(!t.eql(y,t.ONE))throw new Error("invZ was invalid");return{x:q,y:S}}isTorsionFree(){const{h:f,isTorsionFree:h}=e;if(f===k)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:h}=e;return f===k?this:h?h(l,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return this.assertValidity(),r(l,this,f)}toHex(f=!0){return at(this.toRawBytes(f))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);const I=e.nBitLength,A=xn(l,e.endo?Math.ceil(I/2):I);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:o,weierstrassEquation:c,isWithinCurveOrder:d}}function Nn(n){const e=Kt(n);return wt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function _n(n){const e=Nn(n),{Fp:t,n:r}=e,i=t.BYTES+1,c=2*t.BYTES+1;function d(u){return P<u&&u<t.ORDER}function s(u){return Z(u,r)}function o(u){return xt(u,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:b,weierstrassEquation:l,isWithinCurveOrder:I}=On({...e,toBytes(u,w,B){const _=w.toAffine(),N=t.toBytes(_.x),C=ht;return B?C(Uint8Array.from([w.hasEvenY()?2:3]),N):C(Uint8Array.from([4]),N,t.toBytes(_.y))},fromBytes(u){const w=u.length,B=u[0],_=u.subarray(1);if(w===i&&(B===2||B===3)){const N=ot(_);if(!d(N))throw new Error("Point is not on curve");const C=l(N);let R;try{R=t.sqrt(C)}catch(Y){const X=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+X)}const L=(R&k)===k;return(B&1)===1!==L&&(R=t.neg(R)),{x:N,y:R}}else if(w===c&&B===4){const N=t.fromBytes(_.subarray(0,t.BYTES)),C=t.fromBytes(_.subarray(t.BYTES,2*t.BYTES));return{x:N,y:C}}else throw new Error(`Point of length ${w} was invalid. Expected ${i} compressed bytes or ${c} uncompressed bytes`)}}),A=u=>at(lt(u,e.nByteLength));function p(u){const w=r>>k;return u>w}function f(u){return p(u)?s(-u):u}const h=(u,w,B)=>ot(u.slice(w,B));class g{constructor(w,B,_){this.r=w,this.s=B,this.recovery=_,this.assertValidity()}static fromCompact(w){const B=e.nByteLength;return w=M("compactSignature",w,B*2),new g(h(w,0,B),h(w,B,2*B))}static fromDER(w){const{r:B,s:_}=rt.toSig(M("DER",w));return new g(B,_)}assertValidity(){if(!I(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!I(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(w){return new g(this.r,this.s,w)}recoverPublicKey(w){const{r:B,s:_,recovery:N}=this,C=E(M("msgHash",w));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const R=N===2||N===3?B+e.n:B;if(R>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const L=N&1?"03":"02",W=a.fromHex(L+A(R)),Y=o(R),X=s(-C*Y),dt=s(_*Y),Q=a.BASE.multiplyAndAddUnsafe(W,X,dt);if(!Q)throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return ut(this.toDERHex())}toDERHex(){return rt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ut(this.toCompactHex())}toCompactHex(){return A(this.r)+A(this.s)}}const m={isValidPrivateKey(u){try{return b(u),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const u=Yt(e.n);return mn(e.randomBytes(u),e.n)},precompute(u=8,w=a.BASE){return w._setWindowSize(u),w.multiply(BigInt(3)),w}};function x(u,w=!0){return a.fromPrivateKey(u).toRawBytes(w)}function q(u){const w=it(u),B=typeof u=="string",_=(w||B)&&u.length;return w?_===i||_===c:B?_===2*i||_===2*c:u instanceof a}function S(u,w,B=!0){if(q(u))throw new Error("first arg must be private key");if(!q(w))throw new Error("second arg must be public key");return a.fromHex(w).multiply(b(u)).toRawBytes(B)}const y=e.bits2int||function(u){const w=ot(u),B=u.length*8-e.nBitLength;return B>0?w>>BigInt(B):w},E=e.bits2int_modN||function(u){return s(y(u))},v=qt(e.nBitLength);function V(u){if(typeof u!="bigint")throw new Error("bigint expected");if(!(P<=u&&u<v))throw new Error(`bigint expected < 2^${e.nBitLength}`);return lt(u,e.nByteLength)}function $(u,w,B=O){if(["recovered","canonical"].some(nt=>nt in B))throw new Error("sign() legacy options not supported");const{hash:_,randomBytes:N}=e;let{lowS:C,prehash:R,extraEntropy:L}=B;C==null&&(C=!0),u=M("msgHash",u),R&&(u=M("prehashed msgHash",_(u)));const W=E(u),Y=b(w),X=[V(Y),V(W)];if(L!=null&&L!==!1){const nt=L===!0?N(t.BYTES):L;X.push(M("extraEntropy",nt))}const dt=ht(...X),Q=W;function yt(nt){const st=y(nt);if(!I(st))return;const Ot=o(st),ct=a.BASE.multiply(st).toAffine(),K=s(ct.x);if(K===P)return;const ft=s(Ot*s(Q+K*Y));if(ft===P)return;let Nt=(ct.x===K?0:2)|Number(ct.y&k),_t=ft;return C&&p(ft)&&(_t=f(ft),Nt^=1),new g(K,_t,Nt)}return{seed:dt,k2sig:yt}}const O={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};function z(u,w,B=O){const{seed:_,k2sig:N}=$(u,w,B),C=e;return Vt(C.hash.outputLen,C.nByteLength,C.hmac)(_,N)}a.BASE._setWindowSize(8);function D(u,w,B,_=H){var ct;const N=u;if(w=M("msgHash",w),B=M("publicKey",B),"strict"in _)throw new Error("options.strict was renamed to lowS");const{lowS:C,prehash:R}=_;let L,W;try{if(typeof N=="string"||it(N))try{L=g.fromDER(N)}catch(K){if(!(K instanceof rt.Err))throw K;L=g.fromCompact(N)}else if(typeof N=="object"&&typeof N.r=="bigint"&&typeof N.s=="bigint"){const{r:K,s:ft}=N;L=new g(K,ft)}else throw new Error("PARSE");W=a.fromHex(B)}catch(K){if(K.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(C&&L.hasHighS())return!1;R&&(w=e.hash(w));const{r:Y,s:X}=L,dt=E(w),Q=o(X),yt=s(dt*Q),nt=s(Y*Q),st=(ct=a.BASE.multiplyAndAddUnsafe(W,yt,nt))==null?void 0:ct.toAffine();return st?s(st.x)===Y:!1}return{CURVE:e,getPublicKey:x,getSharedSecret:S,sign:z,verify:D,ProjectivePoint:a,Signature:g,utils:m}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function $n(n){return{hash:n,hmac:(e,...t)=>Wt(n,e,Xt(...t)),randomBytes:Qt}}function Tn(n,e){const t=r=>_n({...n,...$n(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Mt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Rt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Cn=BigInt(1),Bt=BigInt(2),Lt=(n,e)=>(n+e/Bt)/e;function Un(n){const e=Mt,t=BigInt(3),r=BigInt(6),i=BigInt(11),c=BigInt(22),d=BigInt(23),s=BigInt(44),o=BigInt(88),a=n*n*n%e,b=a*a*n%e,l=j(b,t,e)*b%e,I=j(l,t,e)*b%e,A=j(I,Bt,e)*a%e,p=j(A,i,e)*A%e,f=j(p,c,e)*p%e,h=j(f,s,e)*f%e,g=j(h,o,e)*h%e,m=j(g,s,e)*f%e,x=j(m,t,e)*b%e,q=j(x,d,e)*p%e,S=j(q,r,e)*a%e,y=j(S,Bt,e);if(!vt.eql(vt.sqr(y),n))throw new Error("Cannot find square root");return y}const vt=pn(Mt,void 0,void 0,{sqrt:Un}),Zn=Tn({a:BigInt(0),b:BigInt(7),Fp:vt,n:Rt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Rt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Cn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),c=t,d=BigInt("0x100000000000000000000000000000000"),s=Lt(c*n,e),o=Lt(-r*n,e);let a=Z(n-s*t-o*i,e),b=Z(-s*r-o*c,e);const l=a>d,I=b>d;if(l&&(a=e-a),I&&(b=e-b),a>d||b>d)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:l,k1:a,k2neg:I,k2:b}}}},Sn);BigInt(0);Zn.ProjectivePoint;export{pn as F,wt as a,It as b,at as c,ht as d,M as e,Hn as f,Sn as g,Tn as h,Ln as i,Z as m,At as n,j as p,Zn as s,Kt as v,xn as w};
