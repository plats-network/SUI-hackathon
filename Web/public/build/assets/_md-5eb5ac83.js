function H(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function U(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function a(t,...e){if(!U(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function I(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");H(t.outputLen),H(t.blockLen)}function p(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function k(t,e){a(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const y=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),w=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),st=(t,e)=>t<<32-e|t>>>e,E=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,_=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255,ot=E?t=>t:t=>_(t);function it(t){for(let e=0;e<t.length;e++)t[e]=_(t[e])}const S=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function rt(t){a(t);let e="";for(let n=0;n<t.length;n++)e+=S[t[n]];return e}const h={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function x(t){if(t>=h._0&&t<=h._9)return t-h._0;if(t>=h._A&&t<=h._F)return t-(h._A-10);if(t>=h._a&&t<=h._f)return t-(h._a-10)}function ct(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(n);for(let o=0,i=0;o<n;o++,i+=2){const r=x(t.charCodeAt(i)),c=x(t.charCodeAt(i+1));if(r===void 0||c===void 0){const f=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+i)}s[o]=r*16+c}return s}function T(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function g(t){return typeof t=="string"&&(t=T(t)),a(t),t}function ht(...t){let e=0;for(let s=0;s<t.length;s++){const o=t[s];a(o),e+=o.length}const n=new Uint8Array(e);for(let s=0,o=0;s<t.length;s++){const i=t[s];n.set(i,o),o+=i.length}return n}class A{clone(){return this._cloneInto()}}function ft(t){const e=s=>t().update(g(s)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function ut(t){const e=(s,o)=>t(o).update(g(s)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>t(s),e}function at(t=32){if(y&&typeof y.getRandomValues=="function")return y.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}const d=BigInt(2**32-1),b=BigInt(32);function B(t,e=!1){return e?{h:Number(t&d),l:Number(t>>b&d)}:{h:Number(t>>b&d)|0,l:Number(t&d)|0}}function C(t,e=!1){let n=new Uint32Array(t.length),s=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:r}=B(t[o],e);[n[o],s[o]]=[i,r]}return[n,s]}const M=(t,e)=>BigInt(t>>>0)<<b|BigInt(e>>>0),N=(t,e,n)=>t>>>n,j=(t,e,n)=>t<<32-n|e>>>n,O=(t,e,n)=>t>>>n|e<<32-n,V=(t,e,n)=>t<<32-n|e>>>n,R=(t,e,n)=>t<<64-n|e>>>n-32,D=(t,e,n)=>t>>>n-32|e<<64-n,F=(t,e)=>e,q=(t,e)=>t,v=(t,e,n)=>t<<n|e>>>32-n,K=(t,e,n)=>e<<n|t>>>32-n,P=(t,e,n)=>e<<n-32|t>>>64-n,W=(t,e,n)=>t<<n-32|e>>>64-n;function $(t,e,n,s){const o=(e>>>0)+(s>>>0);return{h:t+n+(o/2**32|0)|0,l:o|0}}const z=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),G=(t,e,n,s)=>e+n+s+(t/2**32|0)|0,J=(t,e,n,s)=>(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),Q=(t,e,n,s,o)=>e+n+s+o+(t/2**32|0)|0,X=(t,e,n,s,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0)+(o>>>0),Y=(t,e,n,s,o,i)=>e+n+s+o+i+(t/2**32|0)|0,Z={fromBig:B,split:C,toBig:M,shrSH:N,shrSL:j,rotrSH:O,rotrSL:V,rotrBH:R,rotrBL:D,rotr32H:F,rotr32L:q,rotlSH:v,rotlSL:K,rotlBH:P,rotlBL:W,add:$,add3L:z,add3H:G,add4L:J,add4H:Q,add5H:Y,add5L:X},lt=Z;class m extends A{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,I(e);const s=g(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(s.length>o?e.create().update(s).digest():s);for(let r=0;r<i.length;r++)i[r]^=54;this.iHash.update(i),this.oHash=e.create();for(let r=0;r<i.length;r++)i[r]^=106;this.oHash.update(i),i.fill(0)}update(e){return p(this),this.iHash.update(e),this}digestInto(e){p(this),a(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:s,finished:o,destroyed:i,blockLen:r,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=r,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const tt=(t,e,n)=>new m(t,e).update(n).digest();tt.create=(t,e)=>new m(t,e);function et(t,e,n,s){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,s);const o=BigInt(32),i=BigInt(4294967295),r=Number(n>>o&i),c=Number(n&i),f=s?4:0,l=s?0:4;t.setUint32(e+f,r,s),t.setUint32(e+l,c,s)}const dt=(t,e,n)=>t&e^~t&n,pt=(t,e,n)=>t&e^t&n^e&n;class gt extends A{constructor(e,n,s,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=s,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=w(this.buffer)}update(e){p(this);const{view:n,buffer:s,blockLen:o}=this;e=g(e);const i=e.length;for(let r=0;r<i;){const c=Math.min(o-this.pos,i-r);if(c===o){const f=w(e);for(;o<=i-r;r+=o)this.process(f,r);continue}s.set(e.subarray(r,r+c),this.pos),this.pos+=c,r+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){p(this),k(e,this),this.finished=!0;const{buffer:n,view:s,blockLen:o,isLE:i}=this;let{pos:r}=this;n[r++]=128,this.buffer.subarray(r).fill(0),this.padOffset>o-r&&(this.process(s,0),r=0);for(let u=r;u<o;u++)n[u]=0;et(s,o-8,BigInt(this.length*8),i),this.process(s,0);const c=w(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=f/4,L=this.get();if(l>L.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<l;u++)c.setUint32(4*u,L[u],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const s=e.slice(0,n);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:s,length:o,finished:i,destroyed:r,pos:c}=this;return e.length=o,e.pos=c,e.finished=i,e.destroyed=r,o%n&&e.buffer.set(s),e}}export{dt as C,gt as H,pt as M,A as a,nt as b,it as c,ot as d,p as e,ut as f,st as g,tt as h,E as i,ht as j,ct as k,rt as l,a as m,H as n,k as o,P as p,v as q,at as r,C as s,g as t,lt as u,W as v,ft as w,K as x};
