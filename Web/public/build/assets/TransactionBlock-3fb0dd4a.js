import{f as ft,s as Gt,B as Vt,g as Ft,b as s,c as Kt,t as Lt,d as dt,e as ne,a as Wt,i as Ae}from"./legacy-registry-4fcefa09.js";import{b as zt}from"./blake2b-0b963f07.js";class Jt extends TypeError{constructor(t,n){let r;const{message:i,explanation:c,...u}=t,{path:f}=t,p=f.length===0?i:`At path: ${f.join(".")} -- ${i}`;super(c??p),c!=null&&(this.cause=p),Object.assign(this,u),this.name=this.constructor.name,this.failures=()=>r??(r=[t,...n()])}}function Ht(e){return C(e)&&typeof e[Symbol.iterator]=="function"}function C(e){return typeof e=="object"&&e!=null}function R(e){return typeof e=="symbol"?e.toString():typeof e=="string"?JSON.stringify(e):`${e}`}function Xt(e){const{done:t,value:n}=e.next();return t?void 0:n}function Zt(e,t,n,r){if(e===!0)return;e===!1?e={}:typeof e=="string"&&(e={message:e});const{path:i,branch:c}=t,{type:u}=n,{refinement:f,message:p=`Expected a value of type \`${u}\`${f?` with refinement \`${f}\``:""}, but received: \`${R(r)}\``}=e;return{value:r,type:u,refinement:f,key:i[i.length-1],path:i,branch:c,...e,message:p}}function*it(e,t,n,r){Ht(e)||(e=[e]);for(const i of e){const c=Zt(i,t,n,r);c&&(yield c)}}function*_e(e,t,n={}){const{path:r=[],branch:i=[e],coerce:c=!1,mask:u=!1}=n,f={path:r,branch:i};if(c&&(e=t.coercer(e,f),u&&t.type!=="type"&&C(t.schema)&&C(e)&&!Array.isArray(e)))for(const b in e)t.schema[b]===void 0&&delete e[b];let p="valid";for(const b of t.validator(e,f))b.explanation=n.message,p="not_valid",yield[b,void 0];for(let[b,m,k]of t.entries(e,f)){const v=_e(m,k,{path:b===void 0?r:[...r,b],branch:b===void 0?i:[...i,m],coerce:c,mask:u,message:n.message});for(const U of v)U[0]?(p=U[0].refinement!=null?"not_refined":"not_valid",yield[U[0],void 0]):c&&(m=U[1],b===void 0?e=m:e instanceof Map?e.set(b,m):e instanceof Set?e.add(m):C(e)&&(m!==void 0||b in e)&&(e[b]=m))}if(p!=="not_valid")for(const b of t.refiner(e,f))b.explanation=n.message,p="not_refined",yield[b,void 0];p==="valid"&&(yield[void 0,e])}class ${constructor(t){const{type:n,schema:r,validator:i,refiner:c,coercer:u=p=>p,entries:f=function*(){}}=t;this.type=n,this.schema=r,this.entries=f,this.coercer=u,i?this.validator=(p,b)=>{const m=i(p,b);return it(m,b,this,p)}:this.validator=()=>[],c?this.refiner=(p,b)=>{const m=c(p,b);return it(m,b,this,p)}:this.refiner=()=>[]}assert(t,n){return we(t,this,n)}create(t,n){return lt(t,this,n)}is(t){return _(t,this)}mask(t,n){return pt(t,this,n)}validate(t,n={}){return ce(t,this,n)}}function we(e,t,n){const r=ce(e,t,{message:n});if(r[0])throw r[0]}function lt(e,t,n){const r=ce(e,t,{coerce:!0,message:n});if(r[0])throw r[0];return r[1]}function pt(e,t,n){const r=ce(e,t,{coerce:!0,mask:!0,message:n});if(r[0])throw r[0];return r[1]}function _(e,t){return!ce(e,t)[0]}function ce(e,t,n={}){const r=_e(e,t,n),i=Xt(r);return i[0]?[new Jt(i[0],function*(){for(const u of r)u[0]&&(yield u[0])}),void 0]:[void 0,i[1]]}function re(...e){const t=e[0].type==="type",n=e.map(i=>i.schema),r=Object.assign({},...n);return t?Yt(r):a(r)}function M(e,t){return new $({type:e,schema:null,validator:t})}function Oe(){return M("any",()=>!0)}function h(e){return new $({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[n,r]of t.entries())yield[n,r,e]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${R(t)}`}})}function qt(){return M("bigint",e=>typeof e=="bigint")}function E(){return M("boolean",e=>typeof e=="boolean")}function B(){return M("integer",e=>typeof e=="number"&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${R(e)}`)}function l(e){const t=R(e),n=typeof e;return new $({type:"literal",schema:n==="string"||n==="number"||n==="boolean"?e:null,validator(r){return r===e||`Expected the literal \`${t}\`, but received: ${R(r)}`}})}function gt(){return M("never",()=>!1)}function T(e){return new $({...e,validator:(t,n)=>t===null||e.validator(t,n),refiner:(t,n)=>t===null||e.refiner(t,n)})}function Z(){return M("number",e=>typeof e=="number"&&!isNaN(e)||`Expected a number, but received: ${R(e)}`)}function a(e){const t=e?Object.keys(e):[],n=gt();return new $({type:"object",schema:e||null,*entries(r){if(e&&C(r)){const i=new Set(Object.keys(r));for(const c of t)i.delete(c),yield[c,r[c],e[c]];for(const c of i)yield[c,r[c],n]}},validator(r){return C(r)||`Expected an object, but received: ${R(r)}`},coercer(r){return C(r)?{...r}:r}})}function d(e){return new $({...e,validator:(t,n)=>t===void 0||e.validator(t,n),refiner:(t,n)=>t===void 0||e.refiner(t,n)})}function N(e,t){return new $({type:"record",schema:null,*entries(n){if(C(n))for(const r in n){const i=n[r];yield[r,r,e],yield[r,i,t]}},validator(n){return C(n)||`Expected an object, but received: ${R(n)}`}})}function o(){return M("string",e=>typeof e=="string"||`Expected a string, but received: ${R(e)}`)}function bt(e){const t=gt();return new $({type:"tuple",schema:null,*entries(n){if(Array.isArray(n)){const r=Math.max(e.length,n.length);for(let i=0;i<r;i++)yield[i,n[i],e[i]||t]}},validator(n){return Array.isArray(n)||`Expected an array, but received: ${R(n)}`}})}function Yt(e){const t=Object.keys(e);return new $({type:"type",schema:e,*entries(n){if(C(n))for(const r of t)yield[r,n[r],e[r]]},validator(n){return C(n)||`Expected an object, but received: ${R(n)}`},coercer(n){return C(n)?{...n}:n}})}function j(e){const t=e.map(n=>n.type).join(" | ");return new $({type:"union",schema:null,coercer(n){for(const r of e){const[i,c]=r.validate(n,{coerce:!0});if(!i)return c}return n},validator(n,r){const i=[];for(const c of e){const[...u]=_e(n,c,r),[f]=u;if(f[0])for(const[p]of u)p&&i.push(p);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${R(n)}`,...i]}})}function ht(){return M("unknown",()=>!0)}const Me=j([a({AddressOwner:o()}),a({ObjectOwner:o()}),a({Shared:a({initial_shared_version:T(o())})}),l("Immutable")]);M("SuiJsonValue",()=>!0);const Qt=j([a({u32:o()}),a({u64:o()}),a({f64:o()})]);a({attributes:N(o(),T(Qt)),featureFlags:N(o(),E()),maxSupportedProtocolVersion:o(),minSupportedProtocolVersion:o(),protocolVersion:o()});j([o(),l("package")]);const W=a({digest:o(),objectId:o(),version:j([Z(),o(),qt()])});a({owner:Me,reference:W});a({objectId:o(),sequenceNumber:o()});a({payment:h(W),owner:o(),price:o(),budget:o()});const en=re(W,a({type:o(),owner:Me,previousTransaction:o()})),tn=N(o(),Oe()),nn=N(o(),ht()),rn=a({type:o(),fields:tn,hasPublicTransfer:E()}),sn=a({disassembled:nn}),on=j([re(rn,a({dataType:l("moveObject")})),re(sn,a({dataType:l("package")}))]),an=a({type:o(),hasPublicTransfer:E(),version:o(),bcsBytes:o()}),cn=a({id:o(),moduleMap:N(o(),o())}),un=j([re(an,a({dataType:l("moveObject")})),re(cn,a({dataType:l("package")}))]);BigInt(1e9);const mt=a({code:o(),error:d(o()),object_id:d(o()),parent_object_id:d(o()),version:d(o()),digest:d(o())}),fn=a({data:T(d(N(o(),o()))),error:T(d(mt))}),dn=j([fn,d(N(o(),o()))]),yt=a({objectId:o(),version:o(),digest:o(),type:T(d(o())),content:T(d(on)),bcs:T(d(un)),owner:T(d(Me)),previousTransaction:T(d(o())),storageRebate:T(d(o())),display:T(d(dn))});a({showType:T(d(E())),showContent:T(d(E())),showBcs:T(d(E())),showOwner:T(d(E())),showPreviousTransaction:T(d(E())),showStorageRebate:T(d(E())),showDisplay:T(d(E()))});j([l("Exists"),l("notExists"),l("Deleted")]);h(en);const ln=a({data:T(d(yt)),error:T(d(mt))});function pn(e){return e.data}function gn(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){const t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}function ot(e){if("reference"in e)return e.reference;const t=pn(e);return t?{objectId:t.objectId,version:t.version,digest:t.digest}:gn(e)}a({objectId:o(),atCheckpoint:d(Z())});a({data:h(ln),nextCursor:d(T(o())),hasNextPage:E()});j([a({details:yt,status:l("VersionFound")}),a({details:o(),status:l("ObjectNotExists")}),a({details:W,status:l("ObjectDeleted")}),a({details:bt([o(),Z()]),status:l("VersionNotFound")}),a({details:a({asked_version:Z(),latest_version:Z(),object_id:o()}),status:l("VersionTooHigh")})]);const bn=j([o(),a({Object:o()})]);h(bn);const hn=a({address:o(),name:o()}),mn=j([l("Private"),l("Public"),l("Friend")]),Ce=a({abilities:h(o())}),yn=a({constraints:Ce,isPhantom:E()}),Sn=a({TypeParameter:Z()}),Se=bt([a({module:o(),package:o(),function:o()}),o()]);a({rank3Days:h(Se),rank7Days:h(Se),rank30Days:h(Se)});function St(e){if(!e)return!1;if(typeof e=="string"||_(e,Sn)||Tt(e))return!0;if(typeof e!="object")return!1;const t=e;return!!(_(t.Reference,Y)||_(t.MutableReference,Y)||_(t.Vector,Y))}const Y=M("SuiMoveNormalizedType",St);function Tt(e){if(!e||typeof e!="object")return!1;const t=e;if(!t.Struct||typeof t.Struct!="object")return!1;const n=t.Struct;return!(typeof n.address!="string"||typeof n.module!="string"||typeof n.name!="string"||!Array.isArray(n.typeArguments)||!n.typeArguments.every(r=>St(r)))}M("SuiMoveNormalizedStructType",Tt);const Tn=a({visibility:mn,isEntry:E(),typeParameters:h(Ce),parameters:h(Y),return:h(Y)}),jn=a({name:o(),type:Y}),wn=a({abilities:Ce,typeParameters:h(yn),fields:h(jn)}),On=a({fileFormatVersion:Z(),address:o(),name:o(),friends:h(hn),structs:N(o(),wn),exposedFunctions:N(o(),Tn)});N(o(),On);function ve(e){return typeof e=="object"&&"MutableReference"in e?e.MutableReference:void 0}function jt(e){return typeof e=="object"&&"Reference"in e?e.Reference:void 0}function Re(e){if(typeof e=="object"&&"Struct"in e)return e;const t=jt(e),n=ve(e);if(typeof t=="object"&&"Struct"in t)return t;if(typeof n=="object"&&"Struct"in n)return n}const vn=32;function mr(e){try{return ft(e).length===vn}catch{return!1}}const Pe=32;function wt(e){return xn(e)&&kn(e)===Pe}function yr(e){return wt(e)}function x(e,t=!1){let n=e.toLowerCase();return!t&&n.startsWith("0x")&&(n=n.slice(2)),`0x${n.padStart(Pe*2,"0")}`}function se(e,t=!1){return x(e,t)}function xn(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2===0}function kn(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}BigInt(1e9);const De="0x1",Ot="0x2";se("0x6");const En=`${Ot}::sui::SUI`;se("0x5");const In="object",An="ID",_n="ascii",Mn="String",Cn="string",Rn="String",Pn="option",Dn="Option",Nn={address:Ot,module:In,name:An},Un={address:De,module:_n,name:Mn},Bn={address:De,module:Cn,name:Rn},$n={address:De,module:Pn,name:Dn},fe=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function Gn(e){var n;const t=(n=Re(e))==null?void 0:n.Struct;return(t==null?void 0:t.address)==="0x2"&&(t==null?void 0:t.module)==="tx_context"&&(t==null?void 0:t.name)==="TxContext"}function Te(e,t){if(!(typeof t>"u")&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const Vn=["Address","Bool","U8","U16","U32","U64","U128","U256"];function xe(e,t){if(typeof e=="string"&&Vn.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])Te("number",t);else if(e==="Bool")Te("boolean",t);else if(e==="Address"&&(Te("string",t),t&&!wt(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}else if(typeof e=="string")throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((t===void 0||typeof t=="string")&&e.Vector==="U8")return"string";if(t!==void 0&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const n=xe(e.Vector,t?t[0]:void 0);return n===void 0?void 0:`vector<${n}>`}if("Struct"in e){if(fe(e.Struct,Un))return"string";if(fe(e.Struct,Bn))return"utf8string";if(fe(e.Struct,Nn))return"address";if(fe(e.Struct,$n)){const n={Vector:e.Struct.typeArguments[0]};return xe(n,t)}}}const Fn=/^vector<(.+)>$/,Kn=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class F{static parseFromStr(t,n=!1){if(t==="address")return{address:null};if(t==="bool")return{bool:null};if(t==="u8")return{u8:null};if(t==="u16")return{u16:null};if(t==="u32")return{u32:null};if(t==="u64")return{u64:null};if(t==="u128")return{u128:null};if(t==="u256")return{u256:null};if(t==="signer")return{signer:null};const r=t.match(Fn);if(r)return{vector:F.parseFromStr(r[1],n)};const i=t.match(Kn);if(i)return{struct:{address:n?x(i[1]):i[1],module:i[2],name:i[3],typeParams:i[5]===void 0?[]:F.parseStructTypeArgs(i[5],n)}};throw new Error(`Encountered unexpected token when parsing type args for ${t}`)}static parseStructTypeArgs(t,n=!1){return Gt(t).map(r=>F.parseFromStr(r,n))}static tagToString(t){if("bool"in t)return"bool";if("u8"in t)return"u8";if("u16"in t)return"u16";if("u32"in t)return"u32";if("u64"in t)return"u64";if("u128"in t)return"u128";if("u256"in t)return"u256";if("address"in t)return"address";if("signer"in t)return"signer";if("vector"in t)return`vector<${F.tagToString(t.vector)}>`;if("struct"in t){const n=t.struct,r=n.typeParams.map(F.tagToString).join(", ");return`${n.address}::${n.module}::${n.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}const S=new Vt({...Ft(),types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function vt(e){return s.u64({name:"unsafe_u64",...e}).transform({input:t=>t,output:t=>Number(t)})}function Ln(e){return s.enum("Option",{None:null,Some:e})}function Ne(e){return e.transform({input:t=>({[t.kind]:t}),output:t=>{const n=Object.keys(t)[0];return{kind:n,...t[n]}}})}const D=s.bytes(Pe).transform({input:e=>typeof e=="string"?Kt(x(e)):e,output:e=>x(Lt(e))}),Ue=s.vector(s.u8()).transform({name:"ObjectDigest",input:e=>ft(e),output:e=>dt(new Uint8Array(e))}),ie=s.struct("SuiObjectRef",{objectId:D,version:s.u64(),digest:Ue}),Be=s.struct("SharedObjectRef",{objectId:D,initialSharedVersion:s.u64(),mutable:s.bool()}),he=s.enum("ObjectArg",{ImmOrOwned:ie,Shared:Be,Receiving:ie}),$e=s.enum("CallArg",{Pure:s.vector(s.u8()),Object:he,ObjVec:s.vector(he)}),Q=s.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:s.lazy(()=>Q),struct:s.lazy(()=>We),u16:null,u32:null,u256:null}),P=Ne(s.enum("Argument",{GasCoin:null,Input:s.struct("Input",{index:s.u16()}),Result:s.struct("Result",{index:s.u16()}),NestedResult:s.struct("NestedResult",{index:s.u16(),resultIndex:s.u16()})})),Ge=s.struct("ProgrammableMoveCall",{package:D,module:s.string(),function:s.string(),type_arguments:s.vector(Q),arguments:s.vector(P)}).transform({input:e=>{const[t,n,r]=e.target.split("::"),i=e.typeArguments.map(c=>F.parseFromStr(c,!0));return{package:x(t),module:n,function:r,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(F.tagToString)})}),Ve=Ne(s.enum("Transaction",{MoveCall:Ge,TransferObjects:s.struct("TransferObjects",{objects:s.vector(P),address:P}),SplitCoins:s.struct("SplitCoins",{coin:P,amounts:s.vector(P)}),MergeCoins:s.struct("MergeCoins",{destination:P,sources:s.vector(P)}),Publish:s.struct("Publish",{modules:s.vector(s.vector(s.u8())),dependencies:s.vector(D)}),MakeMoveVec:s.struct("MakeMoveVec",{type:Ln(Q),objects:s.vector(P)}),Upgrade:s.struct("Upgrade",{modules:s.vector(s.vector(s.u8())),dependencies:s.vector(D),packageId:D,ticket:P})})),Fe=s.struct("ProgrammableTransaction",{inputs:s.vector($e),transactions:s.vector(Ve)}),Ke=s.enum("TransactionKind",{ProgrammableTransaction:Fe,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),Le=s.enum("TransactionExpiration",{None:null,Epoch:vt()}),We=s.struct("StructTag",{address:D,module:s.string(),name:s.string(),typeParams:s.vector(Q)}),ze=s.struct("GasData",{payment:s.vector(ie),owner:D,price:s.u64(),budget:s.u64()}),Je=s.struct("TransactionDataV1",{kind:Ke,sender:D,gasData:ze,expiration:Le}),He=s.enum("TransactionData",{V1:Je}),Wn=s.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),zn=s.enum("IntentVersion",{V0:null}),Jn=s.enum("AppId",{Sui:null}),Hn=s.struct("Intent",{scope:Wn,version:zn,appId:Jn}),Xn=s.generic(["T"],e=>s.struct("IntentMessage<T>",{intent:Hn,value:e})),Xe=s.enum("CompressedSignature",{ED25519:s.fixedArray(64,s.u8()),Secp256k1:s.fixedArray(64,s.u8()),Secp256r1:s.fixedArray(64,s.u8()),ZkLogin:s.vector(s.u8())}),Ze=s.enum("PublicKey",{ED25519:s.fixedArray(32,s.u8()),Secp256k1:s.fixedArray(33,s.u8()),Secp256r1:s.fixedArray(33,s.u8()),ZkLogin:s.vector(s.u8())}),qe=s.struct("MultiSigPkMap",{pubKey:Ze,weight:s.u8()}),Ye=s.struct("MultiSigPublicKey",{pk_map:s.vector(qe),threshold:s.u16()}),xt=s.struct("MultiSig",{sigs:s.vector(Xe),bitmap:s.u16(),multisig_pk:Ye}),Zn=s.vector(s.u8()).transform({input:e=>typeof e=="string"?ne(e):e,output:e=>Wt(new Uint8Array(e))}),kt=s.struct("SenderSignedTransaction",{intentMessage:Xn(He),txSignatures:s.vector(Zn)}),Et=s.vector(kt,{name:"SenderSignedData"}),w={...s,U8:s.u8(),U16:s.u16(),U32:s.u32(),U64:s.u64(),U128:s.u128(),U256:s.u256(),ULEB128:s.uleb128(),Bool:s.bool(),String:s.string(),Address:D,Argument:P,CallArg:$e,CompressedSignature:Xe,GasData:ze,MultiSig:xt,MultiSigPkMap:qe,MultiSigPublicKey:Ye,ObjectArg:he,ObjectDigest:Ue,ProgrammableMoveCall:Ge,ProgrammableTransaction:Fe,PublicKey:Ze,SenderSignedData:Et,SenderSignedTransaction:kt,SharedObjectRef:Be,StructTag:We,SuiObjectRef:ie,Transaction:Ve,TransactionData:He,TransactionDataV1:Je,TransactionExpiration:Le,TransactionKind:Ke,TypeTag:Q,ser:S.ser.bind(S),de:S.de.bind(S),getTypeInterface:S.getTypeInterface.bind(S),hasType:S.hasType.bind(S),parseTypeName:S.parseTypeName.bind(S),registerAddressType:S.registerAddressType.bind(S),registerAlias:S.registerAlias.bind(S),registerBcsType:S.registerBcsType.bind(S),registerEnumType:S.registerEnumType.bind(S),registerStructType:S.registerStructType.bind(S),registerType:S.registerType.bind(S),types:S.types};S.registerBcsType("utf8string",()=>s.string({name:"utf8string"}));S.registerBcsType("unsafe_u64",()=>vt());S.registerBcsType("enumKind",e=>Ne(e));[D,P,$e,Xe,ze,xt,qe,Ye,he,Ue,Ge,Fe,Ze,Et,Be,We,ie,Ve,He,Je,Le,Ke,Q].forEach(e=>{S.registerBcsType(e.name,()=>e)});const qn=j([a({ImmOrOwned:W}),a({Shared:a({objectId:o(),initialSharedVersion:j([B(),o()]),mutable:E()})}),a({Receiving:W})]),me=a({Pure:h(B())}),ke=a({Object:qn}),ye=j([me,ke]);function Yn(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:Ae(e)?e.toBytes():w.ser(t,e,{maxSize:1/0}).toBytes())}}const A={Pure:Yn,ObjectRef({objectId:e,digest:t,version:n}){return{Object:{ImmOrOwned:{digest:t,version:n,objectId:x(e)}}}},SharedObjectRef({objectId:e,mutable:t,initialSharedVersion:n}){return{Object:{Shared:{mutable:t,initialSharedVersion:n,objectId:x(e)}}}},ReceivingRef({objectId:e,digest:t,version:n}){return{Object:{Receiving:{digest:t,version:n,objectId:x(e)}}}}};function at(e){return typeof e=="string"?x(e):"ImmOrOwned"in e.Object?x(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?x(e.Object.Receiving.objectId):x(e.Object.Shared.objectId)}function Qn(e){return typeof e=="object"&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}function er(e){var t;return((t=Qn(e))==null?void 0:t.mutable)??!1}function I(e,t){return lt(e,t)}const tr=e=>j([a({None:j([l(!0),l(null)])}),a({Some:e})]),oe=j([a({kind:l("Input"),index:B(),value:d(Oe()),type:d(l("object"))}),a({kind:l("Input"),index:B(),value:d(Oe()),type:l("pure")})]),nr=[oe,a({kind:l("GasCoin")}),a({kind:l("Result"),index:B()}),a({kind:l("NestedResult"),index:B(),resultIndex:B()})],L=j([...nr]),It=a({kind:l("MoveCall"),target:M("target",o().validator),typeArguments:h(o()),arguments:h(L)}),At=a({kind:l("TransferObjects"),objects:h(L),address:L}),_t=a({kind:l("SplitCoins"),coin:L,amounts:h(L)}),Mt=a({kind:l("MergeCoins"),destination:L,sources:h(L)}),Ct=a({kind:l("MakeMoveVec"),type:d(tr(N(o(),ht()))),objects:h(L)}),Rt=a({kind:l("Publish"),modules:h(h(B())),dependencies:h(o())}),Pt=a({kind:l("Upgrade"),modules:h(h(B())),dependencies:h(o()),packageId:o(),ticket:L}),rr=[It,At,_t,Mt,Rt,Pt,Ct],sr=j([...rr]),X={MoveCall(e){return I({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},It)},TransferObjects(e,t){return t.kind==="Input"&&t.type==="pure"&&typeof t.value!="object"&&(t.value=A.Pure(w.Address.serialize(t.value))),I({kind:"TransferObjects",objects:e,address:t},At)},SplitCoins(e,t){return t.forEach(n=>{n.kind==="Input"&&n.type==="pure"&&typeof n.value!="object"&&(n.value=A.Pure(w.U64.serialize(n.value)))}),I({kind:"SplitCoins",coin:e,amounts:t},_t)},MergeCoins(e,t){return I({kind:"MergeCoins",destination:e,sources:t},Mt)},Publish({modules:e,dependencies:t}){return I({kind:"Publish",modules:e.map(n=>typeof n=="string"?Array.from(ne(n)):n),dependencies:t.map(n=>se(n))},Rt)},Upgrade({modules:e,dependencies:t,packageId:n,ticket:r}){return I({kind:"Upgrade",modules:e.map(i=>typeof i=="string"?Array.from(ne(i)):i),dependencies:t.map(i=>se(i)),packageId:n,ticket:r},Pt)},MakeMoveVec({type:e,objects:t}){return I({kind:"MakeMoveVec",type:e?{Some:F.parseFromStr(e)}:{None:null},objects:t},Ct)}};function ir(e){function t(n,r){return e(n,r)}return t.u8=n=>e(w.U8.serialize(n)),t.u16=n=>e(w.U16.serialize(n)),t.u32=n=>e(w.U32.serialize(n)),t.u64=n=>e(w.U64.serialize(n)),t.u128=n=>e(w.U128.serialize(n)),t.u256=n=>e(w.U256.serialize(n)),t.bool=n=>e(w.Bool.serialize(n)),t.string=n=>e(w.String.serialize(n)),t.address=n=>e(w.Address.serialize(n)),t.id=t.address,t}function or(e,t){const n=Array.from(`${e}::`).map(i=>i.charCodeAt(0)),r=new Uint8Array(n.length+t.length);return r.set(n),r.set(t,n.length),zt(r,{dkLen:32})}const ar=d(T(j([a({Epoch:B()}),a({None:j([l(!0),l(null)])})]))),ct=M("StringEncodedBigint",e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}}),cr=a({budget:d(ct),price:d(ct),payment:d(h(W)),owner:d(o())}),de=a({version:l(1),sender:d(o()),expiration:ar,gasConfig:cr,inputs:h(oe),transactions:h(sr)});function ut(e){return x(e).replace("0x","")}class K{constructor(t){this.version=1,this.sender=t==null?void 0:t.sender,this.expiration=t==null?void 0:t.expiration,this.gasConfig=(t==null?void 0:t.gasConfig)??{},this.inputs=(t==null?void 0:t.inputs)??[],this.transactions=(t==null?void 0:t.transactions)??[]}static fromKindBytes(t){const n=w.TransactionKind.parse(t),r="ProgrammableTransaction"in n?n.ProgrammableTransaction:null;if(!r)throw new Error("Unable to deserialize from bytes.");const i=I({version:1,gasConfig:{},inputs:r.inputs.map((c,u)=>I({kind:"Input",value:c,index:u,type:_(c,me)?"pure":"object"},oe)),transactions:r.transactions},de);return K.restore(i)}static fromBytes(t){var u;const n=w.TransactionData.parse(t),r=n==null?void 0:n.V1,i="ProgrammableTransaction"in r.kind?(u=r==null?void 0:r.kind)==null?void 0:u.ProgrammableTransaction:null;if(!r||!i)throw new Error("Unable to deserialize from bytes.");const c=I({version:1,sender:r.sender,expiration:r.expiration,gasConfig:r.gasData,inputs:i.inputs.map((f,p)=>I({kind:"Input",value:f,index:p,type:_(f,me)?"pure":"object"},oe)),transactions:i.transactions},de);return K.restore(c)}static restore(t){we(t,de);const n=new K;return Object.assign(n,t),n}static getDigestFromBytes(t){const n=or("TransactionData",t);return dt(n)}build({maxSizeBytes:t=1/0,overrides:n,onlyTransactionKind:r}={}){const i=this.inputs.map(m=>(we(m.value,ye),m.value)),c={ProgrammableTransaction:{inputs:i,transactions:this.transactions}};if(r)return w.TransactionKind.serialize(c,{maxSize:t}).toBytes();const u=(n==null?void 0:n.expiration)??this.expiration,f=(n==null?void 0:n.sender)??this.sender,p={...this.gasConfig,...n==null?void 0:n.gasConfig};if(!f)throw new Error("Missing transaction sender");if(!p.budget)throw new Error("Missing gas budget");if(!p.payment)throw new Error("Missing gas payment");if(!p.price)throw new Error("Missing gas price");const b={sender:ut(f),expiration:u||{None:!0},gasData:{payment:p.payment,owner:ut(this.gasConfig.owner??f),price:BigInt(p.price),budget:BigInt(p.budget)},kind:{ProgrammableTransaction:{inputs:i,transactions:this.transactions}}};return w.TransactionData.serialize({V1:b},{maxSize:t}).toBytes()}getDigest(){const t=this.build({onlyTransactionKind:!1});return K.getDigestFromBytes(t)}snapshot(){return I(this,de)}}var Qe=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)},y=(e,t,n)=>(Qe(e,t,"read from private field"),n?n.call(e):t.get(e)),V=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},le=(e,t,n,r)=>(Qe(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n),O=(e,t,n)=>(Qe(e,t,"access private method"),n),g,ee,pe,te,ge,z,q,et,Dt,tt,Nt,nt,Ut,rt,Bt,be,Ee;const ur={maxPureArgumentSize:16*1024,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:128*1024};function fr(e){const t={kind:"Result",index:e},n=[],r=i=>n[i]??(n[i]={kind:"NestedResult",index:e,resultIndex:i});return new Proxy(t,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,c){if(c in i)return Reflect.get(i,c);if(c===Symbol.iterator)return function*(){let f=0;for(;;)yield r(f),f++};if(typeof c=="symbol")return;const u=parseInt(c,10);if(!(Number.isNaN(u)||u<0))return r(u)}})}function dr(e){const t=Re(e);return t?t.Struct.address==="0x2"&&t.Struct.module==="transfer"&&t.Struct.name==="Receiving":!1}function ae(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const $t=Symbol.for("@mysten/transaction"),je={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},lr=1000n,pr=50,gr=(e,t)=>Array.from({length:Math.ceil(e.length/t)},(n,r)=>e.slice(r*t,r*t+t));function Sr(e){return!!e&&typeof e=="object"&&e[$t]===!0}const Ie=class{constructor(e){V(this,ee),V(this,te),V(this,z),V(this,et),V(this,tt),V(this,nt),V(this,rt),V(this,be),V(this,g,void 0),le(this,g,new K(e?e.blockData:void 0))}static fromKind(e){const t=new Ie;return le(t,g,K.fromKindBytes(typeof e=="string"?ne(e):e)),t}static from(e){const t=new Ie;return typeof e!="string"||!e.startsWith("{")?le(t,g,K.fromBytes(typeof e=="string"?ne(e):e)):le(t,g,K.restore(JSON.parse(e))),t}setSender(e){y(this,g).sender=e}setSenderIfNotSet(e){y(this,g).sender||(y(this,g).sender=e)}setExpiration(e){y(this,g).expiration=e}setGasPrice(e){y(this,g).gasConfig.price=String(e)}setGasBudget(e){y(this,g).gasConfig.budget=String(e)}setGasOwner(e){y(this,g).gasConfig.owner=e}setGasPayment(e){y(this,g).gasConfig.payment=e.map(t=>pt(t,W))}get blockData(){return y(this,g).snapshot()}get[$t](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:ir((e,t)=>Ae(e)?O(this,ee,pe).call(this,"pure",{Pure:Array.from(e.toBytes())}):O(this,ee,pe).call(this,"pure",e instanceof Uint8Array?A.Pure(e):t?A.Pure(e,t):e))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if(typeof e=="object"&&"kind"in e)return e;const t=at(e),n=y(this,g).inputs.find(r=>r.type==="object"&&t===at(r.value));return n&&_(n.value,ke)&&"Shared"in n.value.Object&&_(e,ke)&&"Shared"in e.Object&&(n.value.Object.Shared.mutable=n.value.Object.Shared.mutable||e.Object.Shared.mutable),n??O(this,ee,pe).call(this,"object",typeof e=="string"?x(e):e)}objectRef(...e){return this.object(A.ObjectRef(...e))}receivingRef(...e){return this.object(A.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(A.SharedObjectRef(...e))}add(e){const t=y(this,g).transactions.push(e);return fr(t-1)}splitCoins(e,t){return this.add(X.SplitCoins(typeof e=="string"?this.object(e):e,t.map(n=>typeof n=="number"||typeof n=="bigint"||typeof n=="string"?this.pure.u64(n):O(this,te,ge).call(this,n))))}mergeCoins(e,t){return this.add(X.MergeCoins(typeof e=="string"?this.object(e):e,t.map(n=>typeof n=="string"?this.object(n):n)))}publish({modules:e,dependencies:t}){return this.add(X.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,packageId:n,ticket:r}){return this.add(X.Upgrade({modules:e,dependencies:t,packageId:n,ticket:typeof r=="string"?this.object(r):r}))}moveCall({arguments:e,typeArguments:t,target:n}){return this.add(X.MoveCall({arguments:e==null?void 0:e.map(r=>O(this,te,ge).call(this,r)),typeArguments:t,target:n}))}transferObjects(e,t){return this.add(X.TransferObjects(e.map(n=>typeof n=="string"?this.object(n):n),typeof t=="string"?this.pure.address(t):O(this,te,ge).call(this,t)))}makeMoveVec({type:e,objects:t}){return this.add(X.MakeMoveVec({type:e,objects:t.map(n=>typeof n=="string"?this.object(n):n)}))}serialize(){return JSON.stringify(y(this,g).snapshot())}async sign(e){const{signer:t,...n}=e,r=await this.build(n);return t.signTransactionBlock(r)}async build(e={}){return await O(this,be,Ee).call(this,e),y(this,g).build({maxSizeBytes:O(this,z,q).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await O(this,be,Ee).call(this,e),y(this,g).getDigest()}};let Tr=Ie;g=new WeakMap;ee=new WeakSet;pe=function(e,t){const n=y(this,g).inputs.length,r=I({kind:"Input",value:typeof t=="bigint"?String(t):t,index:n,type:e},oe);return y(this,g).inputs.push(r),r};te=new WeakSet;ge=function(e){return Ae(e)?this.pure(e):e};z=new WeakSet;q=function(e,{protocolConfig:t,limits:n}){if(n&&typeof n[e]=="number")return n[e];if(!t)return ur[e];const r=t==null?void 0:t.attributes[je[e]];if(!r)throw new Error(`Missing expected protocol config: "${je[e]}"`);const i="u64"in r?r.u64:"u32"in r?r.u32:r.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${je[e]}"`);return Number(i)};et=new WeakSet;Dt=function(e){const t=O(this,z,q).call(this,"maxPureArgumentSize",e);y(this,g).inputs.forEach((n,r)=>{if(_(n.value,me)&&n.value.Pure.length>t)throw new Error(`Input at index ${r} is too large, max pure input size is ${t} bytes, got ${n.value.Pure.length} bytes`)})};tt=new WeakSet;Nt=async function(e){if(y(this,g).gasConfig.payment){const i=O(this,z,q).call(this,"maxGasObjects",e);if(y(this,g).gasConfig.payment.length>i)throw new Error(`Payment objects exceed maximum amount: ${i}`)}if(e.onlyTransactionKind||y(this,g).gasConfig.payment)return;const t=y(this,g).gasConfig.owner??y(this,g).sender,r=(await ae(e).getCoins({owner:t,coinType:En})).data.filter(i=>!y(this,g).inputs.find(u=>_(u.value,ye)&&"Object"in u.value&&"ImmOrOwned"in u.value.Object?i.coinObjectId===u.value.Object.ImmOrOwned.objectId:!1)).slice(0,O(this,z,q).call(this,"maxGasObjects",e)-1).map(i=>({objectId:i.coinObjectId,digest:i.digest,version:i.version}));if(!r.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(r)};nt=new WeakSet;Ut=async function(e){e.onlyTransactionKind||y(this,g).gasConfig.price||this.setGasPrice(await ae(e).getReferenceGasPrice())};rt=new WeakSet;Bt=async function(e){const{inputs:t,transactions:n}=y(this,g),r=[],i=[];if(t.forEach(c=>{if(c.type==="object"&&typeof c.value=="string"){i.push({id:x(c.value),input:c});return}}),n.forEach(c=>{if(c.kind==="MoveCall"&&c.arguments.some(f=>f.kind==="Input"&&!_(t[f.index].value,ye))&&r.push(c),c.kind==="SplitCoins"&&c.amounts.forEach(u=>{if(u.kind==="Input"){const f=t[u.index];typeof f.value!="object"&&(f.value=A.Pure(w.U64.serialize(f.value)))}}),c.kind==="TransferObjects"&&c.address.kind==="Input"){const u=t[c.address.index];typeof u.value!="object"&&(u.value=A.Pure(w.Address.serialize(u.value)))}}),r.length&&await Promise.all(r.map(async c=>{const[u,f,p]=c.target.split("::"),b=await ae(e).getNormalizedMoveFunction({package:se(u),module:f,function:p}),k=b.parameters.length>0&&Gn(b.parameters.at(-1))?b.parameters.slice(0,b.parameters.length-1):b.parameters;if(k.length!==c.arguments.length)throw new Error("Incorrect number of arguments.");k.forEach((v,U)=>{const J=c.arguments[U];if(J.kind!=="Input")return;const H=t[J.index];if(_(H.value,ye))return;const G=H.value,ue=xe(v,G);if(ue){H.value=A.Pure(G,ue);return}if(Re(v)!=null||typeof v=="object"&&"TypeParameter"in v){if(typeof G!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(G,null,2)}`);i.push({id:G,input:H,normalizedType:v});return}throw new Error(`Unknown call arg type ${JSON.stringify(v,null,2)} for value ${JSON.stringify(G,null,2)}`)})})),i.length){const c=[...new Set(i.map(({id:m})=>m))],u=gr(c,pr),f=(await Promise.all(u.map(m=>ae(e).multiGetObjects({ids:m,options:{showOwner:!0}})))).flat();let p=new Map(c.map((m,k)=>[m,f[k]]));const b=Array.from(p).filter(([m,k])=>k.error).map(([m,k])=>m);if(b.length)throw new Error(`The following input objects are invalid: ${b.join(", ")}`);i.forEach(({id:m,input:k,normalizedType:v})=>{var G;const U=p.get(m),J=(G=U.data)==null?void 0:G.owner,H=J&&typeof J=="object"&&"Shared"in J?J.Shared.initial_shared_version:void 0;if(H){const ue=v!=null&&ve(v)==null&&jt(v)==null,st=er(k.value)||ue||v!=null&&ve(v)!=null;k.value=A.SharedObjectRef({objectId:m,initialSharedVersion:H,mutable:st})}else v&&dr(v)?k.value=A.ReceivingRef(ot(U)):k.value=A.ObjectRef(ot(U))})}};be=new WeakSet;Ee=async function(e){if(!e.onlyTransactionKind&&!y(this,g).sender)throw new Error("Missing transaction sender");if(!e.protocolConfig&&!e.limits&&e.client&&(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([O(this,nt,Ut).call(this,e),O(this,rt,Bt).call(this,e)]),!e.onlyTransactionKind&&(await O(this,tt,Nt).call(this,e),!y(this,g).gasConfig.budget)){const t=await ae(e).dryRunTransactionBlock({transactionBlock:y(this,g).build({maxSizeBytes:O(this,z,q).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(O(this,z,q).call(this,"maxTxGas",e)),payment:[]}}})});if(t.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const n=lr*BigInt(this.blockData.gasConfig.price||1n),r=BigInt(t.effects.gasUsed.computationCost)+n,i=r+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>r?i:r)}O(this,et,Dt).call(this,e)};export{Pe as S,Tr as T,yr as a,se as b,mr as c,Sr as d,wt as i,x as n,w as s};
