import{a as S,f as L,t as z}from"./legacy-registry-4fcefa09.js";import{i as m,n as w,a as v,b as T,c as W,d as G}from"./TransactionBlock-3fb0dd4a.js";const U="0.50.1",V="1.19.0",j={"-32700":"ParseError","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError"};class O extends Error{}class N extends O{constructor(t,e){super(t),this.code=e,this.type=j[e]??"ServerError"}}class H extends O{constructor(t,e,r){super(t),this.status=e,this.statusText=r}}var B=(s,t,e)=>{if(!t.has(s))throw TypeError("Cannot "+e)},o=(s,t,e)=>(B(s,t,"read from private field"),e?e.call(s):t.get(s)),d=(s,t,e)=>{if(t.has(s))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(s):t.set(s,e)},p=(s,t,e,r)=>(B(s,t,"write to private field"),r?r.call(s,e):t.set(s,e),e),J=(s,t,e,r)=>({set _(a){p(s,t,a,e)},get _(){return o(s,t,r)}}),P=(s,t,e)=>(B(s,t,"access private method"),e),u,f,h,l,_,g,I,R,x,D;function K(s){const t=new URL(s);return t.protocol=t.protocol.replace("http","ws"),t.toString()}const X={WebSocketConstructor:typeof WebSocket<"u"?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class Y{constructor(t,e={}){if(d(this,I),d(this,x),d(this,u,0),d(this,f,0),d(this,h,null),d(this,l,null),d(this,_,new Set),d(this,g,new Map),this.endpoint=t,this.options={...X,...e},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=K(this.endpoint))}async makeRequest(t,e){const r=await P(this,I,R).call(this);return new Promise((a,i)=>{p(this,u,o(this,u)+1),o(this,g).set(o(this,u),{resolve:a,reject:i,timeout:setTimeout(()=>{o(this,g).delete(o(this,u)),i(new Error(`Request timeout: ${t}`))},this.options.callTimeout)}),r.send(JSON.stringify({jsonrpc:"2.0",id:o(this,u),method:t,params:e}))}).then(({error:a,result:i})=>{if(a)throw new N(a.message,a.code);return i})}async subscribe(t){const e=new Q(t);return o(this,_).add(e),await e.subscribe(this),()=>e.unsubscribe(this)}}u=new WeakMap;f=new WeakMap;h=new WeakMap;l=new WeakMap;_=new WeakMap;g=new WeakMap;I=new WeakSet;R=function(){return o(this,l)?o(this,l):(p(this,l,new Promise(s=>{var t;(t=o(this,h))==null||t.close(),p(this,h,new this.options.WebSocketConstructor(this.endpoint)),o(this,h).addEventListener("open",()=>{p(this,f,0),s(o(this,h))}),o(this,h).addEventListener("close",()=>{J(this,f)._++,o(this,f)<=this.options.maxReconnects&&setTimeout(()=>{P(this,x,D).call(this)},this.options.reconnectTimeout)}),o(this,h).addEventListener("message",({data:e})=>{let r;try{r=JSON.parse(e)}catch(a){console.error(new Error(`Failed to parse RPC message: ${e}`,{cause:a}));return}if("id"in r&&r.id!=null&&o(this,g).has(r.id)){const{resolve:a,timeout:i}=o(this,g).get(r.id);clearTimeout(i),a(r)}else if("params"in r){const{params:a}=r;o(this,_).forEach(i=>{i.subscriptionId===a.subscription&&a.subscription===i.subscriptionId&&i.onMessage(a.result)})}})})),o(this,l))};x=new WeakSet;D=async function(){var s;return(s=o(this,h))==null||s.close(),p(this,l,null),Promise.allSettled([...o(this,_)].map(t=>t.subscribe(this)))};class Q{constructor(t){this.subscriptionId=null,this.subscribed=!1,this.input=t}onMessage(t){this.subscribed&&this.input.onMessage(t)}async unsubscribe(t){const{subscriptionId:e}=this;return this.subscribed=!1,e==null?!1:(this.subscriptionId=null,t.makeRequest(this.input.unsubscribe,[e]))}async subscribe(t){this.subscriptionId=null,this.subscribed=!0;const e=await t.makeRequest(this.input.method,this.input.params);this.subscribed&&(this.subscriptionId=e)}}var A=(s,t,e)=>{if(!t.has(s))throw TypeError("Cannot "+e)},n=(s,t,e)=>(A(s,t,"read from private field"),e?e.call(s):t.get(s)),E=(s,t,e)=>{if(t.has(s))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(s):t.set(s,e)},C=(s,t,e,r)=>(A(s,t,"write to private field"),r?r.call(s,e):t.set(s,e),e),Z=(s,t,e)=>(A(s,t,"access private method"),e),y,c,k,M,$;class tt{constructor(t){E(this,M),E(this,y,0),E(this,c,void 0),E(this,k,void 0),C(this,c,t)}fetch(t,e){const r=n(this,c).fetch??globalThis.fetch;if(!this.fetch)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(t,e)}async request(t){var a,i;C(this,y,n(this,y)+1);const e=await this.fetch(((a=n(this,c).rpc)==null?void 0:a.url)??n(this,c).url,{method:"POST",headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":U,"Client-Target-Api-Version":V,...(i=n(this,c).rpc)==null?void 0:i.headers},body:JSON.stringify({jsonrpc:"2.0",id:n(this,y),method:t.method,params:t.params})});if(!e.ok)throw new H(`Unexpected status code: ${e.status}`,e.status,e.statusText);const r=await e.json();if("error"in r&&r.error!=null)throw new N(r.error.message,r.error.code);return r.result}async subscribe(t){const e=await Z(this,M,$).call(this).subscribe(t);return async()=>!!await e()}}y=new WeakMap;c=new WeakMap;k=new WeakMap;M=new WeakSet;$=function(){var s;if(!n(this,k)){const t=n(this,c).WebSocketConstructor??globalThis.WebSocket;if(!t)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");C(this,k,new Y(((s=n(this,c).websocket)==null?void 0:s.url)??n(this,c).url,{WebSocketConstructor:t,...n(this,c).websocket}))}return n(this,k)};function at(s){switch(s){case"mainnet":return"https://fullnode.mainnet.sui.io:443";case"testnet":return"https://fullnode.testnet.sui.io:443";case"devnet":return"https://fullnode.devnet.sui.io:443";case"localnet":return"http://127.0.0.1:9000";default:throw new Error(`Unknown network: ${s}`)}}const et=Symbol.for("@mysten/SuiClient");class ot{get[et](){return!0}constructor(t){this.transport=t.transport??new tt({url:t.url})}async getRpcApiVersion(){return(await this.transport.request({method:"rpc.discover",params:[]})).info.version}async getCoins(t){if(!t.owner||!m(w(t.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getCoins",params:[t.owner,t.coinType,t.cursor,t.limit]})}async getAllCoins(t){if(!t.owner||!m(w(t.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[t.owner,t.cursor,t.limit]})}async getBalance(t){if(!t.owner||!m(w(t.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getBalance",params:[t.owner,t.coinType]})}async getAllBalances(t){if(!t.owner||!m(w(t.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[t.owner]})}async getCoinMetadata(t){return await this.transport.request({method:"suix_getCoinMetadata",params:[t.coinType]})}async getTotalSupply(t){return await this.transport.request({method:"suix_getTotalSupply",params:[t.coinType]})}async call(t,e){return await this.transport.request({method:t,params:e})}async getMoveFunctionArgTypes(t){return await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[t.package,t.module,t.function]})}async getNormalizedMoveModulesByPackage(t){return await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[t.package]})}async getNormalizedMoveModule(t){return await this.transport.request({method:"sui_getNormalizedMoveModule",params:[t.package,t.module]})}async getNormalizedMoveFunction(t){return await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[t.package,t.module,t.function]})}async getNormalizedMoveStruct(t){return await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[t.package,t.module,t.struct]})}async getOwnedObjects(t){if(!t.owner||!m(w(t.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getOwnedObjects",params:[t.owner,{filter:t.filter,options:t.options},t.cursor,t.limit]})}async getObject(t){if(!t.id||!v(T(t.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[t.id,t.options]})}async tryGetPastObject(t){return await this.transport.request({method:"sui_tryGetPastObject",params:[t.id,t.version,t.options]})}async multiGetObjects(t){if(t.ids.forEach(r=>{if(!r||!v(T(r)))throw new Error(`Invalid Sui Object id ${r}`)}),t.ids.length!==new Set(t.ids).size)throw new Error(`Duplicate object ids in batch call ${t.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[t.ids,t.options]})}async queryTransactionBlocks(t){return await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:t.filter,options:t.options},t.cursor,t.limit,(t.order||"descending")==="descending"]})}async getTransactionBlock(t){if(!W(t.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[t.digest,t.options]})}async multiGetTransactionBlocks(t){if(t.digests.forEach(r=>{if(!W(r))throw new Error(`Invalid Transaction digest ${r}`)}),t.digests.length!==new Set(t.digests).size)throw new Error(`Duplicate digests in batch call ${t.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[t.digests,t.options]})}async executeTransactionBlock(t){return await this.transport.request({method:"sui_executeTransactionBlock",params:[typeof t.transactionBlock=="string"?t.transactionBlock:S(t.transactionBlock),Array.isArray(t.signature)?t.signature:[t.signature],t.options,t.requestType]})}async signAndExecuteTransactionBlock({transactionBlock:t,signer:e,...r}){let a;t instanceof Uint8Array?a=t:(t.setSenderIfNotSet(e.toSuiAddress()),a=await t.build({client:this}));const{signature:i,bytes:b}=await e.signTransactionBlock(a);return this.executeTransactionBlock({transactionBlock:b,signature:i,...r})}async getTotalTransactionBlocks(){const t=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[]});return BigInt(t)}async getReferenceGasPrice(){const t=await this.transport.request({method:"suix_getReferenceGasPrice",params:[]});return BigInt(t)}async getStakes(t){if(!t.owner||!m(w(t.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[t.owner]})}async getStakesByIds(t){return t.stakedSuiIds.forEach(e=>{if(!e||!v(T(e)))throw new Error(`Invalid Sui Stake id ${e}`)}),await this.transport.request({method:"suix_getStakesByIds",params:[t.stakedSuiIds]})}async getLatestSuiSystemState(){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[]})}async queryEvents(t){return await this.transport.request({method:"suix_queryEvents",params:[t.query,t.cursor,t.limit,(t.order||"descending")==="descending"]})}async subscribeEvent(t){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[t.filter],onMessage:t.onMessage})}async subscribeTransaction(t){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[t.filter],onMessage:t.onMessage})}async devInspectTransactionBlock(t){var r;let e;if(G(t.transactionBlock))t.transactionBlock.setSenderIfNotSet(t.sender),e=S(await t.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if(typeof t.transactionBlock=="string")e=t.transactionBlock;else if(t.transactionBlock instanceof Uint8Array)e=S(t.transactionBlock);else throw new Error("Unknown transaction block format.");return await this.transport.request({method:"sui_devInspectTransactionBlock",params:[t.sender,e,(r=t.gasPrice)==null?void 0:r.toString(),t.epoch]})}async dryRunTransactionBlock(t){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:[typeof t.transactionBlock=="string"?t.transactionBlock:S(t.transactionBlock)]})}async getDynamicFields(t){if(!t.parentId||!v(T(t.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[t.parentId,t.cursor,t.limit]})}async getDynamicFieldObject(t){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[t.parentId,t.name]})}async getLatestCheckpointSequenceNumber(){const t=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[]});return String(t)}async getCheckpoint(t){return await this.transport.request({method:"sui_getCheckpoint",params:[t.id]})}async getCheckpoints(t){return await this.transport.request({method:"sui_getCheckpoints",params:[t.cursor,t==null?void 0:t.limit,t.descendingOrder]})}async getCommitteeInfo(t){return await this.transport.request({method:"suix_getCommitteeInfo",params:[t==null?void 0:t.epoch]})}async getNetworkMetrics(){return await this.transport.request({method:"suix_getNetworkMetrics",params:[]})}async getAddressMetrics(){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[]})}async getEpochMetrics(t){return await this.transport.request({method:"suix_getEpochMetrics",params:[t==null?void 0:t.cursor,t==null?void 0:t.limit,t==null?void 0:t.descendingOrder]})}async getAllEpochAddressMetrics(t){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[t==null?void 0:t.descendingOrder]})}async getEpochs(t){return await this.transport.request({method:"suix_getEpochs",params:[t==null?void 0:t.cursor,t==null?void 0:t.limit,t==null?void 0:t.descendingOrder]})}async getMoveCallMetrics(){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[]})}async getCurrentEpoch(){return await this.transport.request({method:"suix_getCurrentEpoch",params:[]})}async getValidatorsApy(){return await this.transport.request({method:"suix_getValidatorsApy",params:[]})}async getChainIdentifier(){const t=await this.getCheckpoint({id:"0"}),e=L(t.digest);return z(e.slice(0,4))}async resolveNameServiceAddress(t){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[t.name]})}async resolveNameServiceNames(t){return await this.transport.request({method:"suix_resolveNameServiceNames",params:[t.address,t.cursor,t.limit]})}async getProtocolConfig(t){return await this.transport.request({method:"sui_getProtocolConfig",params:[t==null?void 0:t.version]})}async waitForTransactionBlock({signal:t,timeout:e=60*1e3,pollInterval:r=2*1e3,...a}){const i=AbortSignal.timeout(e),b=new Promise((F,q)=>{i.addEventListener("abort",()=>q(i.reason))});for(b.catch(()=>{});!i.aborted;){t==null||t.throwIfAborted();try{return await this.getTransactionBlock(a)}catch{await Promise.race([new Promise(q=>setTimeout(q,r)),b])}}throw i.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}}export{ot as S,at as g};
